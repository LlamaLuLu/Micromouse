#include "mm_autograde_M2_nice.h"
#include "rtwtypes.h"
#include "mm_autograde_M2_nice_types.h"
#include "mwmathutil.h"
#include <string.h>
#include "mm_autograde_M2_nice_private.h"
#include <stdlib.h>
#include <stddef.h>
#include "rt_logging_mmi.h"
#include "mm_autograde_M2_nice_capi.h"
#include "mwstringutil.h"
#include "mm_autograde_M2_nice_dt.h"
extern void * CreateDiagnosticAsVoidPtr_wrapper ( const char * id , int nargs
, ... ) ; RTWExtModeInfo * gblRTWExtModeInfo = NULL ; void
raccelForceExtModeShutdown ( boolean_T extModeStartPktReceived ) { if ( !
extModeStartPktReceived ) { boolean_T stopRequested = false ;
rtExtModeWaitForStartPkt ( gblRTWExtModeInfo , 3 , & stopRequested ) ; }
rtExtModeShutdown ( 3 ) ; }
#include "slsv_diagnostic_codegen_c_api.h"
#include "slsa_engine_exec.h"
#ifdef RSIM_WITH_SOLVER_MULTITASKING
boolean_T gbl_raccel_isMultitasking = 1 ;
#else
boolean_T gbl_raccel_isMultitasking = 0 ;
#endif
boolean_T gbl_raccel_tid01eq = 1 ; int_T gbl_raccel_NumST = 4 ; const char_T
* gbl_raccel_Version = "25.1 (R2025a) 21-Nov-2024" ; void
raccel_setup_MMIStateLog ( SimStruct * S ) {
#ifdef UseMMIDataLogging
rt_FillStateSigInfoFromMMI ( ssGetRTWLogInfo ( S ) , & ssGetErrorStatus ( S )
) ;
#else
UNUSED_PARAMETER ( S ) ;
#endif
} static DataMapInfo rt_dataMapInfo ; DataMapInfo * rt_dataMapInfoPtr = &
rt_dataMapInfo ; rtwCAPI_ModelMappingInfo * rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; int_T enableFcnCallFlag [ ] = { 1 , 1 , 1 , 1 } ; const char * raccelLoadInputsAndAperiodicHitTimes ( SimStruct * S , const char * inportFileName , int * matFileFormat ) { return rt_RAccelReadInportsMatFile ( S , inportFileName , matFileFormat ) ; }
#include "simstruc.h"
#include "fixedpoint.h"
#include "slsa_engine_exec.h"
#include "simtarget/slSimTgtSLExecSimBridge.h"
#define c1maqusr1t (1U)
#define fh2p20qa35 ((uint8_T)0U)
#define orjgypckdn (-1)
#define az4wgpee0y (4U)
#define az4xivd4ux (80.0)
#define egz3zmqyzt (0.12)
#define f1wxpecy54 (2U)
#define fad4po45m1 (60.0)
#define gjpgqj5mdd (1U)
#define hdurwvxf2i (7U)
#define hitpnsghgy (5U)
#define juuihyq1nj (9U)
#define ky2ffkmsej (10U)
#define mvdsbzjsqh (8U)
#define n31l1rb55f (6U)
#define nv1kkqyxbo (3U)
#define p05b0zukjc (24.0)
B rtB ; X rtX ; DW rtDW ; static SimStruct model_S ; SimStruct * const rtS =
& model_S ; static void cpvtu4asbr ( const real_T x [ 9 ] , real_T y [ 9 ] )
; static void ekw23p03z3 ( const real_T A [ 9 ] , const real_T B_p [ 4473 ] ,
real_T C [ 4473 ] ) ; static void eyo0q11x42 ( const real_T x [ 1491 ] ,
int32_T i_data [ ] , int32_T i_size [ 2 ] ) ; static void gsrcmjw0ug ( void )
; static void cgoxoes3ro ( real_T * lambda ) ; static void ls4od3kfux ( lqgezxb0qr * * pEmxArray , int32_T numDimensions ) ; static void ianmg0smpl ( real_T * x ) ; static void frni2y1egs ( real_T * x ) ; static void hykqgtpupg ( real_T A [ 9 ] , int32_T ipiv [ 3 ] , int32_T * info ) ; static real_T oqrcmmpxbs ( const real_T x [ 9 ] ) ; static real_T flf2eicnum ( const real_T x [ 9 ] ) ; static void nfqanpjdrg ( mgepjkjzts * obj , const real_T xLimWorld [ 2 ] ) ; static void g2dnl35ryz ( mgepjkjzts * obj , const real_T yLimWorld [ 2 ] ) ; static real_T om010eqy24 ( const real_T x [ 9 ] ) ; static void lozjwwea14 ( real_T cfrom , real_T cto , real_T A [ 9 ] ) ; static real_T f5oydpknhc ( int32_T n , const real_T x [ 9 ] , int32_T ix0 ) ; static void jwyxhx0zjc ( int32_T n , real_T a , real_T x [ 9 ] , int32_T ix0 ) ; static real_T pxvhvsc5fd ( int32_T n , const real_T x [ 9 ] , int32_T ix0 , const real_T y [ 9 ] , int32_T iy0 ) ; static void ch4quoego1 ( int32_T n , real_T a , int32_T ix0 , real_T y [ 9 ] , int32_T iy0 ) ; static real_T f5oydpknhcs ( const real_T x [ 3 ] , int32_T ix0 ) ; static void jwyxhx0zjcp ( real_T a , real_T x [ 3 ] , int32_T ix0 ) ; static void ch4quoego1b ( int32_T n , real_T a , const real_T x [ 9 ] , int32_T ix0 , real_T y [ 3 ] , int32_T iy0 ) ; static void ch4quoego1bn ( int32_T n , real_T a , const real_T x [ 3 ] , int32_T ix0 , real_T y [ 9 ] , int32_T iy0 ) ; static void lozjwwea14e ( real_T cfrom , real_T cto , real_T A [ 3 ] ) ; static void braus3dsye ( const real_T A [ 9 ] , real_T U [ 3 ] ) ; static real_T drzqae34jt ( const real_T x [ 9 ] ) ; static real_T drzqae34jte ( const real_T x [ 9 ] ) ; static void gd1yliugt5 ( const real_T A [ 9 ] ) ; static void lhq1b4o55r ( hgwcbtnozn * * pEmxArray , int32_T numDimensions ) ; static void gzgbsn15hy ( hgwcbtnozn * emxArray , int32_T oldNumel ) ; static void btkjx4rwqk ( const real_T x_data [ ] , const int32_T x_size [ 2 ] , const real_T y_data [ ] , const int32_T y_size [ 2 ] , hgwcbtnozn * xx , hgwcbtnozn * yy ) ; static void gkvistfmsu ( const real_T x [ 4 ] , real_T y [ 4 ] ) ; static void afuapkxsaj ( hgwcbtnozn * in1 , const real_T in2 [ 4 ] , const hgwcbtnozn * in3 , const hgwcbtnozn * in4 ) ; static void ejfc1abzql ( hgwcbtnozn * in1 , const real_T in2 [ 4 ] , const hgwcbtnozn * in3 , const hgwcbtnozn * in4 ) ; static void pwmc1mnb1m ( hgwcbtnozn * * pEmxArray ) ; static void ib1qdy4uaj ( lqgezxb0qr * emxArray , int32_T oldNumel ) ; static void ckudj3qznm ( const uint8_T varargin_1 [ 121203 ] , const real_T varargin_2_T [ 9 ] , const real_T varargin_5_XWorldLimits [ 2 ] , const real_T varargin_5_YWorldLimits [ 2 ] , lqgezxb0qr * outputImage ) ; static void aub0azqxc3 ( const uint8_T varargin_1 [ 121203 ] , real_T varargin_2 , lqgezxb0qr * B_e ) ; static void pbx1k3tjdc ( lqgezxb0qr * * pEmxArray ) ; static void ckudj3qznmi ( const uint8_T varargin_1 [ 40401 ] , const real_T varargin_2_T [ 9 ] , const real_T varargin_5_XWorldLimits [ 2 ] , const real_T varargin_5_YWorldLimits [ 2 ] , uint8_T outputImage_data [ ] , int32_T outputImage_size [ 2 ] ) ; static void cpvtu4asbr ( const real_T x [ 9 ] , real_T y [ 9 ] ) { real_T b_x [ 9 ] ; real_T absx11 ; real_T absx21 ; real_T absx31 ; int32_T itmp ; int32_T p1 ; int32_T p2 ; int32_T p3 ; memcpy ( & b_x [ 0 ] , & x [ 0 ] , 9U * sizeof ( real_T ) ) ; p1 = 0 ; p2 = 3 ; p3 = 6 ; absx11 = muDoubleScalarAbs ( x [ 0 ] ) ; absx21 = muDoubleScalarAbs ( x [ 1 ] ) ; absx31 = muDoubleScalarAbs ( x [ 2 ] ) ; if ( ( absx21 > absx11 ) && ( absx21 > absx31 ) ) { p1 = 3 ; p2 = 0 ; b_x [ 0 ] = x [ 1 ] ; b_x [ 1 ] = x [ 0 ] ; b_x [ 3 ] = x [ 4 ] ; b_x [ 4 ] = x [ 3 ] ; b_x [ 6 ] = x [ 7 ] ; b_x [ 7 ] = x [ 6 ] ; } else if ( absx31 > absx11 ) { p1 = 6 ; p3 = 0 ; b_x [ 0 ] = x [ 2 ] ; b_x [ 2 ] = x [ 0 ] ; b_x [ 3 ] = x [ 5 ] ; b_x [ 5 ] = x [ 3 ] ; b_x [ 6 ] = x [ 8 ] ; b_x [ 8 ] = x [ 6 ] ; } b_x [ 1 ] /= b_x [ 0 ] ; b_x [ 2 ] /= b_x [ 0 ] ; b_x [ 4 ] -= b_x [ 1 ] * b_x [ 3 ] ; b_x [ 5 ] -= b_x [ 2 ] * b_x [ 3 ] ; b_x [ 7 ] -= b_x [ 1 ] * b_x [ 6 ] ; b_x [ 8 ] -= b_x [ 2 ] * b_x [ 6 ] ; if ( muDoubleScalarAbs ( b_x [ 5 ] ) > muDoubleScalarAbs ( b_x [ 4 ] ) ) { itmp = p2 ; p2 = p3 ; p3 = itmp ; absx11 = b_x [ 1 ] ; b_x [ 1 ] = b_x [ 2 ] ; b_x [ 2 ] = absx11 ; absx11 = b_x [ 4 ] ; b_x [ 4 ] = b_x [ 5 ] ; b_x [ 5 ] = absx11 ; absx11 = b_x [ 7 ] ; b_x [ 7 ] = b_x [ 8 ] ; b_x [ 8 ] = absx11 ; } b_x [ 5 ] /= b_x [ 4 ] ; b_x [ 8 ] -= b_x [ 5 ] * b_x [ 7 ] ; absx11 = ( b_x [ 1 ] * b_x [ 5 ] - b_x [ 2 ] ) / b_x [ 8 ] ; absx21 = - ( b_x [ 7 ] * absx11 + b_x [ 1 ] ) / b_x [ 4 ] ; y [ p1 ] = ( ( 1.0 - b_x [ 3 ] * absx21 ) - b_x [ 6 ] * absx11 ) / b_x [ 0 ] ; y [ p1 + 1 ] = absx21 ; y [ p1 + 2 ] = absx11 ; absx11 = - b_x [ 5 ] / b_x [ 8 ] ; absx21 = ( 1.0 - b_x [ 7 ] * absx11 ) / b_x [ 4 ] ; y [ p2 ] = - ( b_x [ 3 ] * absx21 + b_x [ 6 ] * absx11 ) / b_x [ 0 ] ; y [ p2 + 1 ] = absx21 ; y [ p2 + 2 ] = absx11 ; absx11 = 1.0 / b_x [ 8 ] ; absx21 = - b_x [ 7 ] * absx11 / b_x [ 4 ] ; y [ p3 ] = - ( b_x [ 3 ] * absx21 + b_x [ 6 ] * absx11 ) / b_x [ 0 ] ; y [ p3 + 1 ] = absx21 ; y [ p3 + 2 ] = absx11 ; } static void ekw23p03z3 ( const real_T A [ 9 ] , const real_T B_p [ 4473 ] , real_T C [ 4473 ] ) { ptrdiff_t k_t ; ptrdiff_t lda_t ; ptrdiff_t ldb_t ; ptrdiff_t ldc_t ; ptrdiff_t m_t ; ptrdiff_t n_t ; real_T alpha1 ; real_T beta1 ; char_T TRANSA1 ; char_T TRANSB1 ; TRANSB1 = 'N' ; TRANSA1 = 'N' ; alpha1 = 1.0 ; beta1 = 0.0 ; m_t = ( ptrdiff_t ) 3 ; n_t = ( ptrdiff_t ) 1491 ; k_t = ( ptrdiff_t ) 3 ; lda_t = ( ptrdiff_t ) 3 ; ldb_t = ( ptrdiff_t ) 3 ; ldc_t = ( ptrdiff_t ) 3 ; dgemm ( & TRANSA1 , & TRANSB1 , & m_t , & n_t , & k_t , & alpha1 , & A [ 0 ] , & lda_t , & B_p [ 0 ] , & ldb_t , & beta1 , & C [ 0 ] , & ldc_t ) ; } static void eyo0q11x42 ( const real_T x [ 1491 ] , int32_T i_data [ ] , int32_T i_size [ 2 ] ) { int32_T idx ; int32_T ii ; boolean_T exitg1 ; idx = 0 ; i_size [ 0 ] = 1 ; i_size [ 1 ] = 1 ; ii = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( ii < 1491 ) ) { if ( x [ ii ] != 0.0 ) { idx = 1 ; i_data [ 0 ] = ii + 1 ; exitg1 = true ; } else { ii ++ ; } } if ( idx == 0 ) { i_size [ 0 ] = 1 ; i_size [ 1 ] = 0 ; } } static void gsrcmjw0ug ( void ) { if ( rtDW . k5vzkvexn5 == NextState_UPDATE_POSITION ) { rtDW . lhfc0ta5ml = ky2ffkmsej ; switch ( ( int32_T ) rtB . hy1sdasjsw ) { case 0 : rtB . nwh2ohbvkv ++ ; break ; case 1 : rtB . kbi5gtax1r ++ ; break ; case 2 : rtB . nwh2ohbvkv -- ; break ; case 3 : rtB . kbi5gtax1r -- ; break ; } rtB . dp50dq5tps ++ ; rtDW . k5vzkvexn5 = NextState_CHECK_DONE ; } else { rtDW . ftjkxzybsy = ( rtB . euqty000s5 > egz3zmqyzt ) ; rtDW . hrd2dtqf1n = ( rtB . aw5fvfkl4k > egz3zmqyzt ) ; rtDW . hvlgcytolm = rtB . gtf5bhspr5 - rtDW . gcoa440zpp ; if ( ( ( rtDW . ftjkxzybsy && ( ! rtDW . gz5an5grm2 ) ) || ( rtDW . hrd2dtqf1n && ( ! rtDW . keotauvojf ) ) ) && ( ! rtDW . km1goje2r1 ) ) { rtDW . gcoa440zpp = rtB . gtf5bhspr5 ; rtDW . glguabnpzh = true ; } rtDW . gz5an5grm2 = rtDW . ftjkxzybsy ; rtDW . keotauvojf = rtDW . hrd2dtqf1n ; if ( rtDW . glguabnpzh && ( rtB . gtf5bhspr5 - rtDW . gcoa440zpp >= 0.16 ) ) { rtB . iaho3wpxg5 = 0.0 ; rtB . fspxye1ya1 = 0.0 ; rtDW . glguabnpzh = false ; rtDW . ahadgjvl0w = 1.0 ; rtDW . km1goje2r1 = false ; rtDW . k5vzkvexn5 = NextState_UPDATE_POSITION ; } else if ( rtB . o4oyjbghkn <= 0.045 ) { rtB . iaho3wpxg5 = 0.0 ; rtB . fspxye1ya1 = 0.0 ; rtDW . ahadgjvl0w = 2.0 ; rtDW . km1goje2r1 = false ; rtDW . k5vzkvexn5 = NextState_UPDATE_POSITION ; } else if ( rtB . gtf5bhspr5 - rtDW . gcoa440zpp >= 0.223 ) { rtB . iaho3wpxg5 = 0.0 ; rtB . fspxye1ya1 = 0.0 ; rtDW . ahadgjvl0w = 3.0 ; rtDW . km1goje2r1 = false ; rtDW . k5vzkvexn5 = NextState_UPDATE_POSITION ; } } } static void cgoxoes3ro ( real_T * lambda ) { real_T q ; real_T varargin_1_data ; int32_T i ; int32_T trueCount ; trueCount = 0 ; if ( ( * lambda < - 3.1415926535897931 ) || ( * lambda > 3.1415926535897931 ) ) { for ( i = 0 ; i < 1 ; i ++ ) { trueCount ++ ; } } for ( i = 0 ; i < trueCount ; i ++ ) { if ( muDoubleScalarIsNaN ( * lambda + 3.1415926535897931 ) || muDoubleScalarIsInf ( * lambda + 3.1415926535897931 ) ) { q = ( rtNaN ) ; } else { q = muDoubleScalarAbs ( ( * lambda + 3.1415926535897931 ) / 6.2831853071795862 ) ; if ( muDoubleScalarAbs ( q - muDoubleScalarFloor ( q + 0.5 ) ) > 2.2204460492503131E-16 * q ) { q = muDoubleScalarRem ( * lambda + 3.1415926535897931 , 6.2831853071795862 ) ; } else { q = 0.0 ; } if ( q == 0.0 ) { q = 0.0 ; } else if ( q < 0.0 ) { q += 6.2831853071795862 ; } } varargin_1_data = q ; } for ( i = 0 ; i < trueCount ; i ++ ) { if ( ( varargin_1_data == 0.0 ) && ( * lambda + 3.1415926535897931 > 0.0 ) ) { varargin_1_data = 6.2831853071795862 ; } } if ( ( * lambda < - 3.1415926535897931 ) || ( * lambda > 3.1415926535897931 ) ) { * lambda = varargin_1_data - 3.1415926535897931 ; } } static void ls4od3kfux ( lqgezxb0qr * * pEmxArray , int32_T numDimensions ) { lqgezxb0qr * emxArray ; int32_T i ; * pEmxArray = ( lqgezxb0qr * ) malloc ( sizeof ( lqgezxb0qr ) ) ; emxArray = * pEmxArray ; emxArray -> data = ( uint8_T * ) NULL ; emxArray -> numDimensions = numDimensions ; emxArray -> size = ( int32_T * ) malloc ( sizeof ( int32_T ) * ( uint32_T ) numDimensions ) ; emxArray -> allocatedSize = 0 ; emxArray -> canFreeData = true ; for ( i = 0 ; i < numDimensions ; i ++ ) { emxArray -> size [ i ] = 0 ; } } static void ianmg0smpl ( real_T * x ) { real_T absx ; real_T b_x ; if ( muDoubleScalarIsInf ( * x ) || muDoubleScalarIsNaN ( * x ) ) { * x = ( rtNaN ) ; } else { b_x = muDoubleScalarRem ( * x , 360.0 ) ; absx = muDoubleScalarAbs ( b_x ) ; if ( absx > 180.0 ) { if ( b_x > 0.0 ) { b_x -= 360.0 ; } else { b_x += 360.0 ; } absx = muDoubleScalarAbs ( b_x ) ; } if ( absx <= 45.0 ) { b_x *= 0.017453292519943295 ; * x = muDoubleScalarSin ( b_x ) ; } else if ( absx <= 135.0 ) { if ( b_x > 0.0 ) { b_x = ( b_x - 90.0 ) * 0.017453292519943295 ; * x = muDoubleScalarCos ( b_x ) ; } else { b_x = ( b_x + 90.0 ) * 0.017453292519943295 ; * x = - muDoubleScalarCos ( b_x ) ; } } else { if ( b_x > 0.0 ) { b_x = ( b_x - 180.0 ) * 0.017453292519943295 ; } else { b_x = ( b_x + 180.0 ) * 0.017453292519943295 ; } * x = - muDoubleScalarSin ( b_x ) ; } } } static void frni2y1egs ( real_T * x ) { real_T absx ; real_T b_x ; if ( muDoubleScalarIsInf ( * x ) || muDoubleScalarIsNaN ( * x ) ) { * x = ( rtNaN ) ; } else { b_x = muDoubleScalarRem ( * x , 360.0 ) ; absx = muDoubleScalarAbs ( b_x ) ; if ( absx > 180.0 ) { if ( b_x > 0.0 ) { b_x -= 360.0 ; } else { b_x += 360.0 ; } absx = muDoubleScalarAbs ( b_x ) ; } if ( absx <= 45.0 ) { b_x *= 0.017453292519943295 ; * x = muDoubleScalarCos ( b_x ) ; } else if ( absx <= 135.0 ) { if ( b_x > 0.0 ) { b_x = ( b_x - 90.0 ) * 0.017453292519943295 ; * x = - muDoubleScalarSin ( b_x ) ; } else { b_x = ( b_x + 90.0 ) * 0.017453292519943295 ; * x = muDoubleScalarSin ( b_x ) ; } } else { if ( b_x > 0.0 ) { b_x = ( b_x - 180.0 ) * 0.017453292519943295 ; } else { b_x = ( b_x + 180.0 ) * 0.017453292519943295 ; } * x = - muDoubleScalarCos ( b_x ) ; } } } static void hykqgtpupg ( real_T A [ 9 ] , int32_T ipiv [ 3 ] , int32_T * info ) { real_T s ; real_T smax ; int32_T b_ix ; int32_T c ; int32_T c_b ; int32_T iy ; int32_T j ; int32_T jj ; int32_T k ; ipiv [ 0 ] = 1 ; ipiv [ 1 ] = 2 ; ipiv [ 2 ] = 3 ; * info = 0 ; for ( j = 0 ; j < 2 ; j ++ ) { jj = j << 2 ; iy = 4 - j ; b_ix = 0 ; smax = muDoubleScalarAbs ( A [ jj ] ) ; for ( k = 2 ; k < iy ; k ++ ) { s = muDoubleScalarAbs ( A [ ( jj + k ) - 1 ] ) ; if ( s > smax ) { b_ix = k - 1 ; smax = s ; } } if ( A [ jj + b_ix ] != 0.0 ) { if ( b_ix != 0 ) { ipiv [ j ] = ( j + b_ix ) + 1 ; iy = j + b_ix ; smax = A [ j ] ; A [ j ] = A [ iy ] ; A [ iy ] = smax ; iy += 3 ; smax = A [ j + 3 ] ; A [ j + 3 ] = A [ iy ] ; A [ iy ] = smax ; iy += 3 ; smax = A [ j + 6 ] ; A [ j + 6 ] = A [ iy ] ; A [ iy ] = smax ; } iy = ( jj - j ) + 3 ; for ( k = jj + 2 ; k <= iy ; k ++ ) { A [ k - 1 ] /= A [ jj ] ; } } else { * info = j + 1 ; } b_ix = jj + 5 ; c = 1 - j ; for ( k = 0 ; k <= c ; k ++ ) { smax = A [ ( k * 3 + jj ) + 3 ] ; if ( A [ ( k * 3 + jj ) + 3 ] != 0.0 ) { c_b = b_ix - j ; for ( iy = b_ix ; iy <= c_b + 1 ; iy ++ ) { A [ iy - 1 ] += A [ ( ( jj + iy ) - b_ix ) + 1 ] * - smax ; } } b_ix += 3 ; } } if ( ( * info == 0 ) && ( ! ( A [ 8 ] != 0.0 ) ) ) { * info = 3 ; } } static real_T oqrcmmpxbs ( const real_T x [ 9 ] ) { real_T ex ; real_T x_p ; int32_T idx ; int32_T k ; boolean_T exitg1 ; if ( ! muDoubleScalarIsNaN ( x [ 0 ] ) ) { idx = 1 ; } else { idx = 0 ; k = 2 ; exitg1 = false ; while ( ( ! exitg1 ) && ( k < 10 ) ) { if ( ! muDoubleScalarIsNaN ( x [ k - 1 ] ) ) { idx = k ; exitg1 = true ; } else { k ++ ; } } } if ( idx == 0 ) { ex = x [ 0 ] ; } else { ex = x [ idx - 1 ] ; for ( k = idx + 1 ; k < 10 ; k ++ ) { x_p = x [ k - 1 ] ; if ( ex > x_p ) { ex = x_p ; } } } return ex ; } static real_T flf2eicnum ( const real_T x [ 9 ] ) { real_T ex ; real_T x_p ; int32_T idx ; int32_T k ; boolean_T exitg1 ; if ( ! muDoubleScalarIsNaN ( x [ 0 ] ) ) { idx = 1 ; } else { idx = 0 ; k = 2 ; exitg1 = false ; while ( ( ! exitg1 ) && ( k < 10 ) ) { if ( ! muDoubleScalarIsNaN ( x [ k - 1 ] ) ) { idx = k ; exitg1 = true ; } else { k ++ ; } } } if ( idx == 0 ) { ex = x [ 0 ] ; } else { ex = x [ idx - 1 ] ; for ( k = idx + 1 ; k < 10 ; k ++ ) { x_p = x [ k - 1 ] ; if ( ex < x_p ) { ex = x_p ; } } } return ex ; } static void nfqanpjdrg ( mgepjkjzts * obj , const real_T xLimWorld [ 2 ] ) { obj -> XWorldLimits [ 0 ] = xLimWorld [ 0 ] ; obj -> XWorldLimits [ 1 ] = xLimWorld [ 1 ] ; obj -> ForcePixelExtentToOne = false ; } static void g2dnl35ryz ( mgepjkjzts * obj , const real_T yLimWorld [ 2 ] ) { obj -> YWorldLimits [ 0 ] = yLimWorld [ 0 ] ; obj -> YWorldLimits [ 1 ] = yLimWorld [ 1 ] ; obj -> ForcePixelExtentToOne = false ; } static real_T om010eqy24 ( const real_T x [ 9 ] ) { real_T absxk ; real_T y ; int32_T k ; boolean_T exitg1 ; y = 0.0 ; k = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( k < 9 ) ) { absxk = muDoubleScalarAbs ( x [ k ] ) ; if ( muDoubleScalarIsNaN ( absxk ) ) { y = ( rtNaN ) ; exitg1 = true ; } else { if ( absxk > y ) { y = absxk ; } k ++ ; } } return y ; } static void lozjwwea14 ( real_T cfrom , real_T cto , real_T A [ 9 ] ) { real_T cfrom1 ; real_T cfromc ; real_T cto1 ; real_T ctoc ; real_T mul ; int32_T j ; int32_T offset ; boolean_T notdone ; cfromc = cfrom ; ctoc = cto ; notdone = true ; while ( notdone ) { cfrom1 = cfromc * 2.0041683600089728E-292 ; cto1 = ctoc / 4.9896007738368E+291 ; if ( ( muDoubleScalarAbs ( cfrom1 ) > muDoubleScalarAbs ( ctoc ) ) && ( ctoc != 0.0 ) ) { mul = 2.0041683600089728E-292 ; cfromc = cfrom1 ; } else if ( muDoubleScalarAbs ( cto1 ) > muDoubleScalarAbs ( cfromc ) ) { mul = 4.9896007738368E+291 ; ctoc = cto1 ; } else { mul = ctoc / cfromc ; notdone = false ; } for ( j = 0 ; j < 3 ; j ++ ) { offset = j * 3 ; A [ offset ] *= mul ; A [ offset + 1 ] *= mul ; A [ offset + 2 ] *= mul ; } } } static real_T f5oydpknhc ( int32_T n , const real_T x [ 9 ] , int32_T ix0 ) { real_T absxk ; real_T scale ; real_T t ; real_T y ; int32_T k ; int32_T kend ; y = 0.0 ; scale = 3.3121686421112381E-170 ; kend = ix0 + n ; for ( k = ix0 ; k < kend ; k ++ ) { absxk = muDoubleScalarAbs ( x [ k - 1 ] ) ; if ( absxk > scale ) { t = scale / absxk ; y = y * t * t + 1.0 ; scale = absxk ; } else { t = absxk / scale ; y += t * t ; } } return scale * muDoubleScalarSqrt ( y ) ; } static void jwyxhx0zjc ( int32_T n , real_T a , real_T x [ 9 ] , int32_T ix0 ) { int32_T b ; int32_T k ; b = ix0 + n ; for ( k = ix0 ; k < b ; k ++ ) { x [ k - 1 ] *= a ; } } static real_T pxvhvsc5fd ( int32_T n , const real_T x [ 9 ] , int32_T ix0 , const real_T y [ 9 ] , int32_T iy0 ) { real_T d ; int32_T b ; int32_T k ; d = 0.0 ; b = ( uint8_T ) n ; for ( k = 0 ; k < b ; k ++ ) { d += x [ ( ix0 + k ) - 1 ] * y [ ( iy0 + k ) - 1 ] ; } return d ; } static void ch4quoego1 ( int32_T n , real_T a , int32_T ix0 , real_T y [ 9 ] , int32_T iy0 ) { int32_T k ; if ( ! ( a == 0.0 ) ) { for ( k = 0 ; k < n ; k ++ ) { y [ ( iy0 + k ) - 1 ] += y [ ( ix0 + k ) - 1 ] * a ; } } } static real_T f5oydpknhcs ( const real_T x [ 3 ] , int32_T ix0 ) { real_T absxk ; real_T scale ; real_T t ; real_T y ; int32_T k ; y = 0.0 ; scale = 3.3121686421112381E-170 ; for ( k = ix0 ; k <= ix0 + 1 ; k ++ ) { absxk = muDoubleScalarAbs ( x [ k - 1 ] ) ; if ( absxk > scale ) { t = scale / absxk ; y = y * t * t + 1.0 ; scale = absxk ; } else { t = absxk / scale ; y += t * t ; } } return scale * muDoubleScalarSqrt ( y ) ; } static void jwyxhx0zjcp ( real_T a , real_T x [ 3 ] , int32_T ix0 ) { int32_T k ; for ( k = ix0 ; k <= ix0 + 1 ; k ++ ) { x [ k - 1 ] *= a ; } } static void ch4quoego1b ( int32_T n , real_T a , const real_T x [ 9 ] , int32_T ix0 , real_T y [ 3 ] , int32_T iy0 ) { int32_T k ; if ( ! ( a == 0.0 ) ) { for ( k = 0 ; k < n ; k ++ ) { y [ ( iy0 + k ) - 1 ] += x [ ( ix0 + k ) - 1 ] * a ; } } } static void ch4quoego1bn ( int32_T n , real_T a , const real_T x [ 3 ] , int32_T ix0 , real_T y [ 9 ] , int32_T iy0 ) { int32_T k ; if ( ! ( a == 0.0 ) ) { for ( k = 0 ; k < n ; k ++ ) { y [ ( iy0 + k ) - 1 ] += x [ ( ix0 + k ) - 1 ] * a ; } } } static void lozjwwea14e ( real_T cfrom , real_T cto , real_T A [ 3 ] ) { real_T cfrom1 ; real_T cfromc ; real_T cto1 ; real_T ctoc ; real_T mul ; boolean_T notdone ; cfromc = cfrom ; ctoc = cto ; notdone = true ; while ( notdone ) { cfrom1 = cfromc * 2.0041683600089728E-292 ; cto1 = ctoc / 4.9896007738368E+291 ; if ( ( muDoubleScalarAbs ( cfrom1 ) > muDoubleScalarAbs ( ctoc ) ) && ( ctoc != 0.0 ) ) { mul = 2.0041683600089728E-292 ; cfromc = cfrom1 ; } else if ( muDoubleScalarAbs ( cto1 ) > muDoubleScalarAbs ( cfromc ) ) { mul = 4.9896007738368E+291 ; ctoc = cto1 ; } else { mul = ctoc / cfromc ; notdone = false ; } A [ 0 ] *= mul ; A [ 1 ] *= mul ; A [ 2 ] *= mul ; } } static void braus3dsye ( const real_T A [ 9 ] , real_T U [ 3 ] ) { real_T b_A [ 9 ] ; real_T e [ 3 ] ; real_T s [ 3 ] ; real_T work [ 3 ] ; real_T anrm ; real_T cscale ; real_T emm1 ; real_T nrm ; real_T rt ; real_T shift ; real_T smm1 ; real_T sqds ; real_T ztest ; int32_T d_ii ; int32_T exitg1 ; int32_T m ; int32_T qjj ; int32_T qp1 ; int32_T qq ; int32_T qs ; boolean_T apply_transform ; boolean_T doscale ; boolean_T exitg2 ; memcpy ( & b_A [ 0 ] , & A [ 0 ] , 9U * sizeof ( real_T ) ) ; s [ 0 ] = 0.0 ; e [ 0 ] = 0.0 ; work [ 0 ] = 0.0 ; s [ 1 ] = 0.0 ; e [ 1 ] = 0.0 ; work [ 1 ] = 0.0 ; s [ 2 ] = 0.0 ; e [ 2 ] = 0.0 ; work [ 2 ] = 0.0 ; doscale = false ; anrm = om010eqy24 ( A ) ; cscale = anrm ; if ( ( anrm > 0.0 ) && ( anrm < 6.7178761075670888E-139 ) ) { doscale = true ; cscale = 6.7178761075670888E-139 ; lozjwwea14 ( anrm , 6.7178761075670888E-139 , b_A ) ; } for ( m = 0 ; m < 2 ; m ++ ) { qp1 = m + 2 ; qq = ( 3 * m + m ) + 1 ; apply_transform = false ; nrm = f5oydpknhc ( 3 - m , b_A , qq ) ; if ( nrm > 0.0 ) { apply_transform = true ; if ( b_A [ qq - 1 ] < 0.0 ) { nrm = - nrm ; } s [ m ] = nrm ; if ( muDoubleScalarAbs ( nrm ) >= 1.0020841800044864E-292 ) { jwyxhx0zjc ( 3 - m , 1.0 / nrm , b_A , qq ) ; } else { qs = ( qq - m ) + 2 ; for ( qjj = qq ; qjj <= qs ; qjj ++ ) { b_A [ qjj - 1 ] /= s [ m ] ; } } b_A [ qq - 1 ] ++ ; s [ m ] = - s [ m ] ; } else { s [ m ] = 0.0 ; } for ( qs = qp1 ; qs < 4 ; qs ++ ) { qjj = ( qs - 1 ) * 3 + m ; if ( apply_transform ) { ch4quoego1 ( 3 - m , - ( pxvhvsc5fd ( 3 - m , b_A , qq , b_A , qjj + 1 ) / b_A [ m + 3 * m ] ) , qq , b_A , qjj + 1 ) ; } e [ qs - 1 ] = b_A [ qjj ] ; } if ( m <= 0 ) { nrm = f5oydpknhcs ( e , 2 ) ; if ( nrm == 0.0 ) { e [ 0 ] = 0.0 ; } else { if ( e [ 1 ] < 0.0 ) { e [ 0 ] = - nrm ; } else { e [ 0 ] = nrm ; } nrm = e [ 0 ] ; if ( muDoubleScalarAbs ( e [ 0 ] ) >= 1.0020841800044864E-292 ) { jwyxhx0zjcp ( 1.0 / e [ 0 ] , e , 2 ) ; } else { for ( qq = qp1 ; qq < 4 ; qq ++ ) { e [ qq - 1 ] /= nrm ; } } e [ 1 ] ++ ; e [ 0 ] = - e [ 0 ] ; for ( qq = qp1 ; qq < 4 ; qq ++ ) { work [ qq - 1 ] = 0.0 ; } for ( qq = qp1 ; qq < 4 ; qq ++ ) { ch4quoego1b ( 2 , e [ qq - 1 ] , b_A , 3 * ( qq - 1 ) + 2 , work , 2 ) ; } for ( qq = qp1 ; qq < 4 ; qq ++ ) { ch4quoego1bn ( 2 , - e [ qq - 1 ] / e [ 1 ] , work , 2 , b_A , 3 * ( qq - 1 ) + 2 ) ; } } } } m = 1 ; s [ 2 ] = b_A [ 8 ] ; e [ 1 ] = b_A [ 7 ] ; e [ 2 ] = 0.0 ; if ( s [ 0 ] != 0.0 ) { rt = muDoubleScalarAbs ( s [ 0 ] ) ; nrm = s [ 0 ] / rt ; s [ 0 ] = rt ; e [ 0 ] /= nrm ; } if ( e [ 0 ] != 0.0 ) { rt = muDoubleScalarAbs ( e [ 0 ] ) ; nrm = rt / e [ 0 ] ; e [ 0 ] = rt ; s [ 1 ] *= nrm ; } if ( s [ 1 ] != 0.0 ) { rt = muDoubleScalarAbs ( s [ 1 ] ) ; nrm = s [ 1 ] / rt ; s [ 1 ] = rt ; e [ 1 ] = b_A [ 7 ] / nrm ; } if ( e [ 1 ] != 0.0 ) { rt = muDoubleScalarAbs ( e [ 1 ] ) ; nrm = rt / e [ 1 ] ; e [ 1 ] = rt ; s [ 2 ] = b_A [ 8 ] * nrm ; } if ( s [ 2 ] != 0.0 ) { s [ 2 ] = muDoubleScalarAbs ( s [ 2 ] ) ; } qp1 = 0 ; nrm = muDoubleScalarMax ( muDoubleScalarMax ( muDoubleScalarMax ( s [ 0 ] , e [ 0 ] ) , muDoubleScalarMax ( s [ 1 ] , e [ 1 ] ) ) , muDoubleScalarMax ( s [ 2 ] , 0.0 ) ) ; while ( ( m + 2 > 0 ) && ( qp1 < 75 ) ) { qjj = m + 1 ; do { exitg1 = 0 ; qq = qjj ; if ( qjj == 0 ) { exitg1 = 1 ; } else { rt = muDoubleScalarAbs ( e [ qjj - 1 ] ) ; if ( ( rt <= ( muDoubleScalarAbs ( s [ qjj - 1 ] ) + muDoubleScalarAbs ( s [ qjj ] ) ) * 2.2204460492503131E-16 ) || ( ( rt <= 1.0020841800044864E-292 ) || ( ( qp1 > 20 ) && ( rt <= 2.2204460492503131E-16 * nrm ) ) ) ) { e [ qjj - 1 ] = 0.0 ; exitg1 = 1 ; } else { qjj -- ; } } } while ( exitg1 == 0 ) ; if ( m + 1 == qjj ) { qjj = 4 ; } else { qs = m + 2 ; d_ii = m + 2 ; exitg2 = false ; while ( ( ! exitg2 ) && ( d_ii >= qjj ) ) { qs = d_ii ; if ( d_ii == qjj ) { exitg2 = true ; } else { rt = 0.0 ; if ( d_ii < m + 2 ) { rt = muDoubleScalarAbs ( e [ d_ii - 1 ] ) ; } if ( d_ii > qjj + 1 ) { rt += muDoubleScalarAbs ( e [ d_ii - 2 ] ) ; } ztest = muDoubleScalarAbs ( s [ d_ii - 1 ] ) ; if ( ( ztest <= 2.2204460492503131E-16 * rt ) || ( ztest <= 1.0020841800044864E-292 ) ) { s [ d_ii - 1 ] = 0.0 ; exitg2 = true ; } else { d_ii -- ; } } } if ( qs == qjj ) { qjj = 3 ; } else if ( m + 2 == qs ) { qjj = 1 ; } else { qjj = 2 ; qq = qs ; } } switch ( qjj ) { case 1 : rt = e [ m ] ; e [ m ] = 0.0 ; for ( qs = m + 1 ; qs >= qq + 1 ; qs -- ) { ztest = 0.0 ; sqds = 0.0 ; drotg ( & s [ qs - 1 ] , & rt , & ztest , & sqds ) ; if ( qs > qq + 1 ) { rt = - sqds * e [ 0 ] ; e [ 0 ] *= ztest ; } } break ; case 2 : rt = e [ qq - 1 ] ; e [ qq - 1 ] = 0.0 ; for ( qs = qq + 1 ; qs <= m + 2 ; qs ++ ) { ztest = 0.0 ; sqds = 0.0 ; drotg ( & s [ qs - 1 ] , & rt , & ztest , & sqds ) ; smm1 = e [ qs - 1 ] ; rt = - sqds * smm1 ; e [ qs - 1 ] = smm1 * ztest ; } break ; case 3 : ztest = muDoubleScalarMax ( muDoubleScalarMax ( muDoubleScalarMax ( muDoubleScalarMax ( muDoubleScalarAbs ( s [ m + 1 ] ) , muDoubleScalarAbs ( s [ m ] ) ) , muDoubleScalarAbs ( e [ m ] ) ) , muDoubleScalarAbs ( s [ qq ] ) ) , muDoubleScalarAbs ( e [ qq ] ) ) ; rt = s [ m + 1 ] / ztest ; smm1 = s [ m ] / ztest ; emm1 = e [ m ] / ztest ; sqds = s [ qq ] / ztest ; smm1 = ( ( smm1 + rt ) * ( smm1 - rt ) + emm1 * emm1 ) / 2.0 ; emm1 *= rt ; emm1 *= emm1 ; if ( ( smm1 != 0.0 ) || ( emm1 != 0.0 ) ) { shift = muDoubleScalarSqrt ( smm1 * smm1 + emm1 ) ; if ( smm1 < 0.0 ) { shift = - shift ; } shift = emm1 / ( smm1 + shift ) ; } else { shift = 0.0 ; } rt = ( sqds + rt ) * ( sqds - rt ) + shift ; sqds *= e [ qq ] / ztest ; for ( qs = qq + 1 ; qs <= m + 1 ; qs ++ ) { ztest = 0.0 ; smm1 = 0.0 ; drotg ( & rt , & sqds , & ztest , & smm1 ) ; if ( qs > qq + 1 ) { e [ 0 ] = rt ; } emm1 = s [ qs - 1 ] ; rt = e [ qs - 1 ] * smm1 + ztest * emm1 ; e [ qs - 1 ] = e [ qs - 1 ] * ztest - smm1 * emm1 ; emm1 = s [ qs ] ; sqds = smm1 * emm1 ; emm1 *= ztest ; ztest = 0.0 ; smm1 = 0.0 ; drotg ( & rt , & sqds , & ztest , & smm1 ) ; s [ qs - 1 ] = rt ; rt = e [ qs - 1 ] * ztest + smm1 * emm1 ; s [ qs ] = e [ qs - 1 ] * - smm1 + ztest * emm1 ; sqds = smm1 * e [ qs ] ; e [ qs ] *= ztest ; } e [ m ] = rt ; qp1 ++ ; break ; default : if ( s [ qq ] < 0.0 ) { s [ qq ] = - s [ qq ] ; } qp1 = qq + 1 ; while ( ( qq + 1 < 3 ) && ( s [ qq ] < s [ qp1 ] ) ) { rt = s [ qq ] ; s [ qq ] = s [ qp1 ] ; s [ qp1 ] = rt ; qq = qp1 ; qp1 ++ ; } qp1 = 0 ; m -- ; break ; } } U [ 0 ] = s [ 0 ] ; U [ 1 ] = s [ 1 ] ; U [ 2 ] = s [ 2 ] ; if ( doscale ) { lozjwwea14e ( cscale , anrm , U ) ; } } static real_T drzqae34jt ( const real_T x [ 9 ] ) { real_T s [ 3 ] ; real_T absx ; real_T y ; int32_T i ; y = 0.0 ; for ( i = 0 ; i < 9 ; i ++ ) { absx = muDoubleScalarAbs ( x [ i ] ) ; if ( muDoubleScalarIsNaN ( absx ) || ( absx > y ) ) { y = absx ; } } if ( ( ! muDoubleScalarIsInf ( y ) ) && ( ! muDoubleScalarIsNaN ( y ) ) ) { braus3dsye ( x , s ) ; y = s [ 0 ] ; } return y ; } static real_T drzqae34jte ( const real_T x [ 9 ] ) { real_T s ; real_T y ; int32_T j ; boolean_T exitg1 ; y = 0.0 ; j = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( j < 3 ) ) { s = ( muDoubleScalarAbs ( x [ 3 * j + 1 ] ) + muDoubleScalarAbs ( x [ 3 * j ] ) ) + muDoubleScalarAbs ( x [ 3 * j + 2 ] ) ; if ( muDoubleScalarIsNaN ( s ) ) { y = ( rtNaN ) ; exitg1 = true ; } else { if ( s > y ) { y = s ; } j ++ ; } } return y ; } static void gd1yliugt5 ( const real_T A [ 9 ] ) { real_T b_A [ 9 ] ; real_T normA ; int32_T ipiv [ 3 ] ; int32_T k ; boolean_T x [ 2 ] ; boolean_T exitg1 ; boolean_T guard1 ; boolean_T y ; guard1 = false ; if ( A [ 8 ] == 1.0 ) { x [ 0 ] = ( A [ 2 ] == 0.0 ) ; x [ 1 ] = ( A [ 5 ] == 0.0 ) ; y = true ; k = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( k < 2 ) ) { if ( ! x [ k ] ) { y = false ; exitg1 = true ; } else { k ++ ; } } if ( y ) { } else { guard1 = true ; } } else { guard1 = true ; } if ( guard1 ) { normA = drzqae34jte ( A ) ; if ( ( ! ( normA == 0.0 ) ) && ( ! muDoubleScalarIsNaN ( normA ) ) ) { memcpy ( & b_A [ 0 ] , & A [ 0 ] , 9U * sizeof ( real_T ) ) ; hykqgtpupg ( b_A , ipiv , & k ) ; } } } static void lhq1b4o55r ( hgwcbtnozn * * pEmxArray , int32_T numDimensions ) { hgwcbtnozn * emxArray ; int32_T i ; * pEmxArray = ( hgwcbtnozn * ) malloc ( sizeof ( hgwcbtnozn ) ) ; emxArray = * pEmxArray ; emxArray -> data = ( real_T * ) NULL ; emxArray -> numDimensions = numDimensions ; emxArray -> size = ( int32_T * ) malloc ( sizeof ( int32_T ) * ( uint32_T ) numDimensions ) ; emxArray -> allocatedSize = 0 ; emxArray -> canFreeData = true ; for ( i = 0 ; i < numDimensions ; i ++ ) { emxArray -> size [ i ] = 0 ; } } static void gzgbsn15hy ( hgwcbtnozn * emxArray , int32_T oldNumel ) { int32_T i ; int32_T newNumel ; void * newData ; if ( oldNumel < 0 ) { oldNumel = 0 ; } newNumel = 1 ; for ( i = 0 ; i < emxArray -> numDimensions ; i ++ ) { newNumel *= emxArray -> size [ i ] ; } if ( newNumel > emxArray -> allocatedSize ) { i = emxArray -> allocatedSize ; if ( i < 16 ) { i = 16 ; } while ( i < newNumel ) { if ( i > 1073741823 ) { i = MAX_int32_T ; } else { i <<= 1 ; } } newData = malloc ( ( uint32_T ) i * sizeof ( real_T ) ) ; if ( emxArray -> data != NULL ) { memcpy ( newData , emxArray -> data , sizeof ( real_T ) * ( uint32_T ) oldNumel ) ; if ( emxArray -> canFreeData ) { free ( emxArray -> data ) ; } } emxArray -> data = ( real_T * ) newData ; emxArray -> allocatedSize = i ; emxArray -> canFreeData = true ; } } static void btkjx4rwqk ( const real_T x_data [ ] , const int32_T x_size [ 2 ] , const real_T y_data [ ] , const int32_T y_size [ 2 ] , hgwcbtnozn * xx , hgwcbtnozn * yy ) { int32_T c ; int32_T d ; int32_T i ; int32_T j ; j = xx -> size [ 0 ] * xx -> size [ 1 ] ; xx -> size [ 0 ] = y_size [ 1 ] ; xx -> size [ 1 ] = x_size [ 1 ] ; gzgbsn15hy ( xx , j ) ; j = yy -> size [ 0 ] * yy -> size [ 1 ] ; yy -> size [ 0 ] = y_size [ 1 ] ; yy -> size [ 1 ] = x_size [ 1 ] ; gzgbsn15hy ( yy , j ) ; c = x_size [ 1 ] ; d = y_size [ 1 ] ; for ( j = 0 ; j < c ; j ++ ) { for ( i = 0 ; i < d ; i ++ ) { xx -> data [ i + xx -> size [ 0 ] * j ] = x_data [ j ] ; yy -> data [ i + yy -> size [ 0 ] * j ] = y_data [ i ] ; } } } static void gkvistfmsu ( const real_T x [ 4 ] , real_T y [ 4 ] ) { real_T r ; real_T t ; if ( muDoubleScalarAbs ( x [ 1 ] ) > muDoubleScalarAbs ( x [ 0 ] ) ) { r = x [ 0 ] / x [ 1 ] ; t = 1.0 / ( r * x [ 3 ] - x [ 2 ] ) ; y [ 0 ] = x [ 3 ] / x [ 1 ] * t ; y [ 1 ] = - t ; y [ 2 ] = - x [ 2 ] / x [ 1 ] * t ; y [ 3 ] = r * t ; } else { r = x [ 1 ] / x [ 0 ] ; t = 1.0 / ( x [ 3 ] - r * x [ 2 ] ) ; y [ 0 ] = x [ 3 ] / x [ 0 ] * t ; y [ 1 ] = - r * t ; y [ 2 ] = - x [ 2 ] / x [ 0 ] * t ; y [ 3 ] = t ; } } static void afuapkxsaj ( hgwcbtnozn * in1 , const real_T in2 [ 4 ] , const hgwcbtnozn * in3 , const hgwcbtnozn * in4 ) { real_T in2_e ; real_T in2_p ; int32_T aux_0_1 ; int32_T aux_1_1 ; int32_T i ; int32_T i_p ; int32_T loop_ub ; int32_T loop_ub_p ; int32_T stride_0_0 ; int32_T stride_0_1 ; int32_T stride_1_0 ; int32_T stride_1_1 ; in2_p = in2 [ 0 ] ; in2_e = in2 [ 2 ] ; if ( in4 -> size [ 0 ] == 1 ) { i_p = in1 -> size [ 0 ] * in1 -> size [ 1 ] ; in1 -> size [ 0 ] = in3 -> size [ 0 ] ; gzgbsn15hy ( in1 , i_p ) ; } else { i_p = in1 -> size [ 0 ] * in1 -> size [ 1 ] ; in1 -> size [ 0 ] = in4 -> size [ 0 ] ; gzgbsn15hy ( in1 , i_p ) ; } if ( in4 -> size [ 1 ] == 1 ) { i_p = in1 -> size [ 0 ] * in1 -> size [ 1 ] ; in1 -> size [ 1 ] = in3 -> size [ 1 ] ; gzgbsn15hy ( in1 , i_p ) ; } else { i_p = in1 -> size [ 0 ] * in1 -> size [ 1 ] ; in1 -> size [ 1 ] = in4 -> size [ 1 ] ; gzgbsn15hy ( in1 , i_p ) ; } stride_0_0 = ( in3 -> size [ 0 ] != 1 ) ; stride_0_1 = ( in3 -> size [ 1 ] != 1 ) ; stride_1_0 = ( in4 -> size [ 0 ] != 1 ) ; stride_1_1 = ( in4 -> size [ 1 ] != 1 ) ; aux_0_1 = 0 ; aux_1_1 = 0 ; if ( in4 -> size [ 1 ] == 1 ) { loop_ub = in3 -> size [ 1 ] ; } else { loop_ub = in4 -> size [ 1 ] ; } for ( i_p = 0 ; i_p < loop_ub ; i_p ++ ) { if ( in4 -> size [ 0 ] == 1 ) { loop_ub_p = in3 -> size [ 0 ] ; } else { loop_ub_p = in4 -> size [ 0 ] ; } for ( i = 0 ; i < loop_ub_p ; i ++ ) { in1 -> data [ i + in1 -> size [ 0 ] * i_p ] = in3 -> data [ i * stride_0_0 + in3 -> size [ 0 ] * aux_0_1 ] * in2_p + in4 -> data [ i * stride_1_0 + in4 -> size [ 0 ] * aux_1_1 ] * in2_e ; } aux_1_1 += stride_1_1 ; aux_0_1 += stride_0_1 ; } } static void ejfc1abzql ( hgwcbtnozn * in1 , const real_T in2 [ 4 ] , const hgwcbtnozn * in3 , const hgwcbtnozn * in4 ) { real_T in2_e ; real_T in2_p ; int32_T aux_0_1 ; int32_T aux_1_1 ; int32_T i ; int32_T i_p ; int32_T loop_ub ; int32_T loop_ub_p ; int32_T stride_0_0 ; int32_T stride_0_1 ; int32_T stride_1_0 ; int32_T stride_1_1 ; in2_p = in2 [ 1 ] ; in2_e = in2 [ 3 ] ; if ( in4 -> size [ 0 ] == 1 ) { i_p = in1 -> size [ 0 ] * in1 -> size [ 1 ] ; in1 -> size [ 0 ] = in3 -> size [ 0 ] ; gzgbsn15hy ( in1 , i_p ) ; } else { i_p = in1 -> size [ 0 ] * in1 -> size [ 1 ] ; in1 -> size [ 0 ] = in4 -> size [ 0 ] ; gzgbsn15hy ( in1 , i_p ) ; } if ( in4 -> size [ 1 ] == 1 ) { i_p = in1 -> size [ 0 ] * in1 -> size [ 1 ] ; in1 -> size [ 1 ] = in3 -> size [ 1 ] ; gzgbsn15hy ( in1 , i_p ) ; } else { i_p = in1 -> size [ 0 ] * in1 -> size [ 1 ] ; in1 -> size [ 1 ] = in4 -> size [ 1 ] ; gzgbsn15hy ( in1 , i_p ) ; } stride_0_0 = ( in3 -> size [ 0 ] != 1 ) ; stride_0_1 = ( in3 -> size [ 1 ] != 1 ) ; stride_1_0 = ( in4 -> size [ 0 ] != 1 ) ; stride_1_1 = ( in4 -> size [ 1 ] != 1 ) ; aux_0_1 = 0 ; aux_1_1 = 0 ; if ( in4 -> size [ 1 ] == 1 ) { loop_ub = in3 -> size [ 1 ] ; } else { loop_ub = in4 -> size [ 1 ] ; } for ( i_p = 0 ; i_p < loop_ub ; i_p ++ ) { if ( in4 -> size [ 0 ] == 1 ) { loop_ub_p = in3 -> size [ 0 ] ; } else { loop_ub_p = in4 -> size [ 0 ] ; } for ( i = 0 ; i < loop_ub_p ; i ++ ) { in1 -> data [ i + in1 -> size [ 0 ] * i_p ] = in3 -> data [ i * stride_0_0 + in3 -> size [ 0 ] * aux_0_1 ] * in2_p + in4 -> data [ i * stride_1_0 + in4 -> size [ 0 ] * aux_1_1 ] * in2_e ; } aux_1_1 += stride_1_1 ; aux_0_1 += stride_0_1 ; } } static void pwmc1mnb1m ( hgwcbtnozn * * pEmxArray ) { if ( * pEmxArray != ( hgwcbtnozn * ) NULL ) { if ( ( ( * pEmxArray ) -> data != ( real_T * ) NULL ) && ( * pEmxArray ) -> canFreeData ) { free ( ( * pEmxArray ) -> data ) ; } free ( ( * pEmxArray ) -> size ) ; free ( * pEmxArray ) ; * pEmxArray = ( hgwcbtnozn * ) NULL ; } } static void ib1qdy4uaj ( lqgezxb0qr * emxArray , int32_T oldNumel ) { int32_T i ; int32_T newNumel ; void * newData ; if ( oldNumel < 0 ) { oldNumel = 0 ; } newNumel = 1 ; for ( i = 0 ; i < emxArray -> numDimensions ; i ++ ) { newNumel *= emxArray -> size [ i ] ; } if ( newNumel > emxArray -> allocatedSize ) { i = emxArray -> allocatedSize ; if ( i < 16 ) { i = 16 ; } while ( i < newNumel ) { if ( i > 1073741823 ) { i = MAX_int32_T ; } else { i <<= 1 ; } } newData = malloc ( ( uint32_T ) i * sizeof ( uint8_T ) ) ; if ( emxArray -> data != NULL ) { memcpy ( newData , emxArray -> data , sizeof ( uint8_T ) * ( uint32_T ) oldNumel ) ; if ( emxArray -> canFreeData ) { free ( emxArray -> data ) ; } } emxArray -> data = ( uint8_T * ) newData ; emxArray -> allocatedSize = i ; emxArray -> canFreeData = true ; } } static void ckudj3qznm ( const uint8_T varargin_1 [ 121203 ] , const real_T varargin_2_T [ 9 ] , const real_T varargin_5_XWorldLimits [ 2 ] , const real_T varargin_5_YWorldLimits [ 2 ] , lqgezxb0qr * outputImage ) { hgwcbtnozn * beta ; hgwcbtnozn * yp ; real_T Ac [ 9 ] ; real_T B_i [ 9 ] ; real_T b_B [ 4 ] ; real_T outputImageSize [ 3 ] ; static const uint8_T fillValues [ 3 ] = { 0U , 0U , 0U } ; hgwcbtnozn * X_T ; hgwcbtnozn * x ; real_T tmp_data [ 201 ] ; real_T tmp_data_p [ 201 ] ; real_T Ac_p [ 9 ] ; real_T Ac_e [ 4 ] ; real_T inputImageSize [ 3 ] ; real_T extentX ; real_T varargin_5_XWorldLimits_p ; int32_T j ; int32_T k ; static const int8_T c [ 3 ] = { 0 , 0 , 1 } ; static const uint8_T b_inputImageSize [ 3 ] = { 207U , 207U , 3U } ; int32_T tmp_size [ 2 ] ; int32_T tmp_size_p [ 2 ] ; for ( j = 0 ; j < 3 ; j ++ ) { B_i [ 3 * j ] = varargin_2_T [ j ] ; B_i [ 3 * j + 1 ] = varargin_2_T [ j + 3 ] ; B_i [ 3 * j + 2 ] = varargin_2_T [ j + 6 ] ; } memcpy ( & Ac [ 0 ] , & B_i [ 0 ] , 9U * sizeof ( real_T ) ) ; Ac [ 2 ] = 0.0 ; Ac [ 5 ] = 0.0 ; Ac [ 8 ] = 1.0 ; drzqae34jt ( Ac ) ; drzqae34jt ( B_i ) ; for ( j = 0 ; j < 9 ; j ++ ) { Ac_p [ j ] = Ac [ j ] - B_i [ j ] ; } drzqae34jt ( Ac_p ) ; gd1yliugt5 ( Ac ) ; tmp_size [ 0 ] = 1 ; tmp_size [ 1 ] = 201 ; tmp_size_p [ 0 ] = 1 ; tmp_size_p [ 1 ] = 201 ; for ( j = 0 ; j < 201 ; j ++ ) { tmp_data [ j ] = ( real_T ) j + 1.0 ; tmp_data_p [ j ] = ( real_T ) j + 1.0 ; } lhq1b4o55r ( & yp , 2 ) ; lhq1b4o55r ( & beta , 2 ) ; btkjx4rwqk ( tmp_data , tmp_size , tmp_data_p , tmp_size_p , beta , yp ) ; extentX = ( varargin_5_XWorldLimits [ 1 ] - varargin_5_XWorldLimits [ 0 ] ) / 201.0 ; k = beta -> size [ 0 ] * beta -> size [ 1 ] ; varargin_5_XWorldLimits_p = varargin_5_XWorldLimits [ 0 ] ; for ( j = 0 ; j < k ; j ++ ) { beta -> data [ j ] = ( beta -> data [ j ] - 0.5 ) * extentX + varargin_5_XWorldLimits_p ; } extentX = ( varargin_5_YWorldLimits [ 1 ] - varargin_5_YWorldLimits [ 0 ] ) / 201.0 ; k = yp -> size [ 0 ] * yp -> size [ 1 ] ; varargin_5_XWorldLimits_p = varargin_5_YWorldLimits [ 0 ] ; for ( j = 0 ; j < k ; j ++ ) { yp -> data [ j ] = ( yp -> data [ j ] - 0.5 ) * extentX + varargin_5_XWorldLimits_p ; } for ( j = 0 ; j < 3 ; j ++ ) { B_i [ 3 * j ] = Ac [ 3 * j ] ; B_i [ 3 * j + 1 ] = Ac [ 3 * j + 1 ] ; B_i [ 3 * j + 2 ] = c [ j ] ; } Ac_e [ 0 ] = Ac [ 0 ] ; Ac_e [ 1 ] = Ac [ 1 ] ; Ac_e [ 2 ] = Ac [ 3 ] ; Ac_e [ 3 ] = Ac [ 4 ] ; gkvistfmsu ( Ac_e , b_B ) ; k = beta -> size [ 0 ] * beta -> size [ 1 ] ; extentX = B_i [ 6 ] ; for ( j = 0 ; j < k ; j ++ ) { beta -> data [ j ] -= extentX ; } k = yp -> size [ 0 ] * yp -> size [ 1 ] ; extentX = B_i [ 7 ] ; for ( j = 0 ; j < k ; j ++ ) { yp -> data [ j ] -= extentX ; } lhq1b4o55r ( & x , 2 ) ; if ( ( beta -> size [ 0 ] == yp -> size [ 0 ] ) && ( beta -> size [ 1 ] == yp -> size [ 1 ] ) ) { extentX = b_B [ 0 ] ; varargin_5_XWorldLimits_p = b_B [ 2 ] ; j = x -> size [ 0 ] * x -> size [ 1 ] ; x -> size [ 0 ] = beta -> size [ 0 ] ; x -> size [ 1 ] = beta -> size [ 1 ] ; gzgbsn15hy ( x , j ) ; k = beta -> size [ 0 ] * beta -> size [ 1 ] ; for ( j = 0 ; j < k ; j ++ ) { x -> data [ j ] = beta -> data [ j ] * extentX + yp -> data [ j ] * varargin_5_XWorldLimits_p ; } } else { afuapkxsaj ( x , b_B , beta , yp ) ; } lhq1b4o55r ( & X_T , 2 ) ; if ( ( beta -> size [ 0 ] == yp -> size [ 0 ] ) && ( beta -> size [ 1 ] == yp -> size [ 1 ] ) ) { extentX = b_B [ 1 ] ; varargin_5_XWorldLimits_p = b_B [ 3 ] ; j = X_T -> size [ 0 ] * X_T -> size [ 1 ] ; X_T -> size [ 0 ] = beta -> size [ 0 ] ; X_T -> size [ 1 ] = beta -> size [ 1 ] ; gzgbsn15hy ( X_T , j ) ; k = beta -> size [ 0 ] * beta -> size [ 1 ] ; for ( j = 0 ; j < k ; j ++ ) { X_T -> data [ j ] = beta -> data [ j ] * extentX + yp -> data [ j ] * varargin_5_XWorldLimits_p ; } } else { ejfc1abzql ( X_T , b_B , beta , yp ) ; } pwmc1mnb1m ( & beta ) ; pwmc1mnb1m ( & yp ) ; k = x -> size [ 0 ] * x -> size [ 1 ] ; for ( j = 0 ; j < k ; j ++ ) { x -> data [ j ] = ( x -> data [ j ] - 0.5 ) + 0.5 ; } k = X_T -> size [ 0 ] * X_T -> size [ 1 ] ; for ( j = 0 ; j < k ; j ++ ) { X_T -> data [ j ] = ( X_T -> data [ j ] - 0.5 ) + 0.5 ; } k = x -> size [ 0 ] * x -> size [ 1 ] ; for ( j = 0 ; j < k ; j ++ ) { x -> data [ j ] += 3.0 ; } k = X_T -> size [ 0 ] * X_T -> size [ 1 ] ; for ( j = 0 ; j < k ; j ++ ) { X_T -> data [ j ] += 3.0 ; } j = outputImage -> size [ 0 ] * outputImage -> size [ 1 ] * outputImage -> size [ 2 ] ; outputImage -> size [ 0 ] = x -> size [ 0 ] ; outputImage -> size [ 1 ] = x -> size [ 1 ] ; outputImage -> size [ 2 ] = 3 ; ib1qdy4uaj ( outputImage , j ) ; for ( k = 0 ; k < 3 ; k ++ ) { for ( j = 0 ; j < 621 ; j ++ ) { rtB . inputImagePadded [ j + k * 42849 ] = 0U ; rtB . inputImagePadded [ ( j + k * 42849 ) + 42228 ] = 0U ; } for ( j = 0 ; j < 201 ; j ++ ) { rtB . inputImagePadded [ 207 * ( j + 3 ) + 42849 * k ] = 0U ; rtB . inputImagePadded [ ( 207 * ( j + 3 ) + 42849 * k ) + 204 ] = 0U ; rtB . inputImagePadded [ ( 207 * ( j + 3 ) + 42849 * k ) + 1 ] = 0U ; rtB . inputImagePadded [ ( 207 * ( j + 3 ) + 42849 * k ) + 205 ] = 0U ; rtB . inputImagePadded [ ( 207 * ( j + 3 ) + 42849 * k ) + 2 ] = 0U ; rtB . inputImagePadded [ ( 207 * ( j + 3 ) + 42849 * k ) + 206 ] = 0U ; memcpy ( & rtB . inputImagePadded [ ( k * 42849 + j * 207 ) + 624 ] , & varargin_1 [ k * 40401 + j * 201 ] , 201U * sizeof ( uint8_T ) ) ; } inputImageSize [ k ] = b_inputImageSize [ k ] ; outputImageSize [ k ] = outputImage -> size [ k ] ; } imterp2d64f_uint8 ( & rtB . inputImagePadded [ 0 ] , & inputImageSize [ 0 ] , & X_T -> data [ 0 ] , & x -> data [ 0 ] , & outputImageSize [ 0 ] , 1.0 , false , & fillValues [ 0 ] , & outputImage -> data [ 0 ] ) ; pwmc1mnb1m ( & x ) ; pwmc1mnb1m ( & X_T ) ; } static void aub0azqxc3 ( const uint8_T varargin_1 [ 121203 ] , real_T varargin_2 , lqgezxb0qr * B_e ) { mgepjkjzts Rout ; real_T T [ 9 ] ; real_T tform_T [ 9 ] ; real_T x [ 9 ] ; real_T idealWorldLimits [ 2 ] ; real_T d ; real_T e ; real_T idealWorldLimits_idx_1 ; real_T idealWorldLimits_idx_3 ; real_T numCols ; real_T numRows ; int32_T ipiv [ 3 ] ; int32_T d_i ; int32_T d_j ; int32_T info ; int8_T k1 ; static const real_T d_p [ 9 ] = { 0.5 , 0.5 , 0.5 , 101.0 , 101.0 , 101.0 , 201.5 , 201.5 , 201.5 } ; static const real_T e_p [ 9 ] = { 0.5 , 101.0 , 201.5 , 0.5 , 101.0 , 201.5 , 0.5 , 101.0 , 201.5 } ; if ( muDoubleScalarRem ( varargin_2 , 90.0 ) == 0.0 ) { numRows = muDoubleScalarFloor ( varargin_2 / 90.0 ) ; if ( muDoubleScalarIsNaN ( numRows ) || muDoubleScalarIsInf ( numRows ) ) { numRows = ( rtNaN ) ; } else { numRows = muDoubleScalarRem ( numRows , 4.0 ) ; if ( numRows == 0.0 ) { numRows = 0.0 ; } else if ( numRows < 0.0 ) { numRows += 4.0 ; } } switch ( ( int32_T ) numRows ) { case 0 : info = B_e -> size [ 0 ] * B_e -> size [ 1 ] * B_e -> size [ 2 ] ; B_e -> size [ 0 ] = 201 ; B_e -> size [ 1 ] = 201 ; B_e -> size [ 2 ] = 3 ; ib1qdy4uaj ( B_e , info ) ; memcpy ( & B_e -> data [ 0 ] , & varargin_1 [ 0 ] , 121203U * sizeof ( uint8_T ) ) ; break ; case 1 : case 3 : if ( muDoubleScalarIsNaN ( numRows ) ) { k1 = 0 ; } else { k1 = ( int8_T ) muDoubleScalarRem ( numRows , 4.0 ) ; } if ( k1 == 1 ) { for ( info = 0 ; info < 3 ; info ++ ) { for ( d_i = 0 ; d_i < 201 ; d_i ++ ) { for ( d_j = 0 ; d_j < 201 ; d_j ++ ) { rtB . b_B [ ( d_i + 201 * d_j ) + 40401 * info ] = varargin_1 [ ( ( 200 - d_i ) * 201 + d_j ) + 40401 * info ] ; } } } } else if ( k1 == 2 ) { for ( info = 0 ; info < 3 ; info ++ ) { for ( d_i = 0 ; d_i < 201 ; d_i ++ ) { for ( d_j = 0 ; d_j < 201 ; d_j ++ ) { rtB . b_B [ ( d_j + 201 * d_i ) + 40401 * info ] = varargin_1 [ ( ( ( 200 - d_i ) * 201 - d_j ) + 40401 * info ) + 200 ] ; } } } } else if ( k1 == 3 ) { for ( info = 0 ; info < 3 ; info ++ ) { for ( d_i = 0 ; d_i < 201 ; d_i ++ ) { for ( d_j = 0 ; d_j < 201 ; d_j ++ ) { rtB . b_B [ ( d_i + 201 * d_j ) + 40401 * info ] = varargin_1 [ ( ( 201 * d_i - d_j ) + 40401 * info ) + 200 ] ; } } } } else { memcpy ( & rtB . b_B [ 0 ] , & varargin_1 [ 0 ] , 121203U * sizeof ( uint8_T ) ) ; } info = B_e -> size [ 0 ] * B_e -> size [ 1 ] * B_e -> size [ 2 ] ; B_e -> size [ 0 ] = 201 ; B_e -> size [ 1 ] = 201 ; B_e -> size [ 2 ] = 3 ; ib1qdy4uaj ( B_e , info ) ; memcpy ( & B_e -> data [ 0 ] , & rtB . b_B [ 0 ] , 121203U * sizeof ( uint8_T ) ) ; break ; case 2 : info = B_e -> size [ 0 ] * B_e -> size [ 1 ] * B_e -> size [ 2 ] ; B_e -> size [ 0 ] = 201 ; B_e -> size [ 1 ] = 201 ; B_e -> size [ 2 ] = 3 ; ib1qdy4uaj ( B_e , info ) ; for ( info = 0 ; info < 3 ; info ++ ) { for ( d_i = 0 ; d_i < 201 ; d_i ++ ) { for ( d_j = 0 ; d_j < 201 ; d_j ++ ) { B_e -> data [ ( d_j + B_e -> size [ 0 ] * d_i ) + B_e -> size [ 0 ] * B_e -> size [ 1 ] * info ] = varargin_1 [ ( ( ( 200 - d_i ) * 201 - d_j ) + 40401 * info ) + 200 ] ; } } } break ; default : info = B_e -> size [ 0 ] * B_e -> size [ 1 ] * B_e -> size [ 2 ] ; B_e -> size [ 0 ] = 201 ; B_e -> size [ 1 ] = 201 ; B_e -> size [ 2 ] = 3 ; ib1qdy4uaj ( B_e , info ) ; memcpy ( & B_e -> data [ 0 ] , & varargin_1 [ 0 ] , 121203U * sizeof ( uint8_T ) ) ; break ; } } else { numRows = varargin_2 ; ianmg0smpl ( & numRows ) ; numCols = varargin_2 ; frni2y1egs ( & numCols ) ; T [ 0 ] = numCols ; T [ 3 ] = - numRows ; T [ 6 ] = 0.0 ; T [ 1 ] = numRows ; T [ 4 ] = numCols ; T [ 7 ] = 0.0 ; T [ 2 ] = 0.0 ; T [ 5 ] = 0.0 ; T [ 8 ] = 1.0 ; memcpy ( & x [ 0 ] , & T [ 0 ] , 9U * sizeof ( real_T ) ) ; hykqgtpupg ( x , ipiv , & info ) ; for ( info = 0 ; info < 9 ; info ++ ) { tform_T [ info ] = T [ info ] ; d = d_p [ info ] ; e = e_p [ info ] ; x [ info ] = numCols * d + numRows * e ; T [ info ] = - numRows * d + numCols * e ; } d = oqrcmmpxbs ( x ) ; e = flf2eicnum ( x ) ; idealWorldLimits_idx_1 = oqrcmmpxbs ( T ) ; idealWorldLimits_idx_3 = flf2eicnum ( T ) ; numCols = ( muDoubleScalarCeil ( e - d ) - ( e - d ) ) / 2.0 ; numRows = ( muDoubleScalarCeil ( idealWorldLimits_idx_3 - idealWorldLimits_idx_1 ) - ( idealWorldLimits_idx_3 - idealWorldLimits_idx_1 ) ) / 2.0 ; idealWorldLimits [ 0 ] = d - numCols ; idealWorldLimits [ 1 ] = e + numCols ; nfqanpjdrg ( & Rout , idealWorldLimits ) ; idealWorldLimits [ 0 ] = idealWorldLimits_idx_1 - numRows ; idealWorldLimits [ 1 ] = idealWorldLimits_idx_3 + numRows ; g2dnl35ryz ( & Rout , idealWorldLimits ) ; numRows = ( Rout . XWorldLimits [ 0 ] + Rout . XWorldLimits [ 1 ] ) / 2.0 ; numCols = ( Rout . YWorldLimits [ 0 ] + Rout . YWorldLimits [ 1 ] ) / 2.0 ; idealWorldLimits [ 0 ] = ( numRows - 101.0 ) + 0.5 ; idealWorldLimits [ 1 ] = ( numRows - 101.0 ) + 201.5 ; nfqanpjdrg ( & Rout , idealWorldLimits ) ; idealWorldLimits [ 0 ] = ( numCols - 101.0 ) + 0.5 ; idealWorldLimits [ 1 ] = ( numCols - 101.0 ) + 201.5 ; g2dnl35ryz ( & Rout , idealWorldLimits ) ; ckudj3qznm ( varargin_1 , tform_T , Rout . XWorldLimits , Rout . YWorldLimits , B_e ) ; } } static void pbx1k3tjdc ( lqgezxb0qr * * pEmxArray ) { if ( * pEmxArray != ( lqgezxb0qr * ) NULL ) { if ( ( ( * pEmxArray ) -> data != ( uint8_T * ) NULL ) && ( * pEmxArray ) -> canFreeData ) { free ( ( * pEmxArray ) -> data ) ; } free ( ( * pEmxArray ) -> size ) ; free ( * pEmxArray ) ; * pEmxArray = ( lqgezxb0qr * ) NULL ; } } static void ckudj3qznmi ( const uint8_T varargin_1 [ 40401 ] , const real_T varargin_2_T [ 9 ] , const real_T varargin_5_XWorldLimits [ 2 ] , const real_T varargin_5_YWorldLimits [ 2 ] , uint8_T outputImage_data [ ] , int32_T outputImage_size [ 2 ] ) { hgwcbtnozn * X_T ; hgwcbtnozn * beta ; hgwcbtnozn * x ; hgwcbtnozn * yp ; real_T tmp_data [ 201 ] ; real_T tmp_data_p [ 201 ] ; real_T Ac [ 9 ] ; real_T Ac_p [ 9 ] ; real_T B_m [ 9 ] ; real_T Ac_e [ 4 ] ; real_T b_B [ 4 ] ; real_T inputImageSize [ 3 ] ; real_T outputImageSize [ 2 ] ; real_T extentX ; real_T varargin_5_XWorldLimits_p ; int32_T i ; int32_T k ; uint8_T fillValues ; static const int8_T c [ 3 ] = { 0 , 0 , 1 } ; int32_T tmp_size [ 2 ] ; int32_T tmp_size_p [ 2 ] ; for ( i = 0 ; i < 3 ; i ++ ) { B_m [ 3 * i ] = varargin_2_T [ i ] ; B_m [ 3 * i + 1 ] = varargin_2_T [ i + 3 ] ; B_m [ 3 * i + 2 ] = varargin_2_T [ i + 6 ] ; } memcpy ( & Ac [ 0 ] , & B_m [ 0 ] , 9U * sizeof ( real_T ) ) ; Ac [ 2 ] = 0.0 ; Ac [ 5 ] = 0.0 ; Ac [ 8 ] = 1.0 ; drzqae34jt ( Ac ) ; drzqae34jt ( B_m ) ; for ( i = 0 ; i < 9 ; i ++ ) { Ac_p [ i ] = Ac [ i ] - B_m [ i ] ; } drzqae34jt ( Ac_p ) ; gd1yliugt5 ( Ac ) ; tmp_size [ 0 ] = 1 ; tmp_size [ 1 ] = 201 ; tmp_size_p [ 0 ] = 1 ; tmp_size_p [ 1 ] = 201 ; for ( i = 0 ; i < 201 ; i ++ ) { tmp_data [ i ] = ( real_T ) i + 1.0 ; tmp_data_p [ i ] = ( real_T ) i + 1.0 ; } lhq1b4o55r ( & yp , 2 ) ; lhq1b4o55r ( & beta , 2 ) ; btkjx4rwqk ( tmp_data , tmp_size , tmp_data_p , tmp_size_p , beta , yp ) ; extentX = ( varargin_5_XWorldLimits [ 1 ] - varargin_5_XWorldLimits [ 0 ] ) / 201.0 ; k = beta -> size [ 0 ] * beta -> size [ 1 ] ; varargin_5_XWorldLimits_p = varargin_5_XWorldLimits [ 0 ] ; for ( i = 0 ; i < k ; i ++ ) { beta -> data [ i ] = ( beta -> data [ i ] - 0.5 ) * extentX + varargin_5_XWorldLimits_p ; } extentX = ( varargin_5_YWorldLimits [ 1 ] - varargin_5_YWorldLimits [ 0 ] ) / 201.0 ; k = yp -> size [ 0 ] * yp -> size [ 1 ] ; varargin_5_XWorldLimits_p = varargin_5_YWorldLimits [ 0 ] ; for ( i = 0 ; i < k ; i ++ ) { yp -> data [ i ] = ( yp -> data [ i ] - 0.5 ) * extentX + varargin_5_XWorldLimits_p ; } for ( i = 0 ; i < 3 ; i ++ ) { B_m [ 3 * i ] = Ac [ 3 * i ] ; B_m [ 3 * i + 1 ] = Ac [ 3 * i + 1 ] ; B_m [ 3 * i + 2 ] = c [ i ] ; } Ac_e [ 0 ] = Ac [ 0 ] ; Ac_e [ 1 ] = Ac [ 1 ] ; Ac_e [ 2 ] = Ac [ 3 ] ; Ac_e [ 3 ] = Ac [ 4 ] ; gkvistfmsu ( Ac_e , b_B ) ; k = beta -> size [ 0 ] * beta -> size [ 1 ] ; extentX = B_m [ 6 ] ; for ( i = 0 ; i < k ; i ++ ) { beta -> data [ i ] -= extentX ; } k = yp -> size [ 0 ] * yp -> size [ 1 ] ; extentX = B_m [ 7 ] ; for ( i = 0 ; i < k ; i ++ ) { yp -> data [ i ] -= extentX ; } lhq1b4o55r ( & x , 2 ) ; if ( ( beta -> size [ 0 ] == yp -> size [ 0 ] ) && ( beta -> size [ 1 ] == yp -> size [ 1 ] ) ) { extentX = b_B [ 0 ] ; varargin_5_XWorldLimits_p = b_B [ 2 ] ; i = x -> size [ 0 ] * x -> size [ 1 ] ; x -> size [ 0 ] = beta -> size [ 0 ] ; x -> size [ 1 ] = beta -> size [ 1 ] ; gzgbsn15hy ( x , i ) ; k = beta -> size [ 0 ] * beta -> size [ 1 ] ; for ( i = 0 ; i < k ; i ++ ) { x -> data [ i ] = beta -> data [ i ] * extentX + yp -> data [ i ] * varargin_5_XWorldLimits_p ; } } else { afuapkxsaj ( x , b_B , beta , yp ) ; } lhq1b4o55r ( & X_T , 2 ) ; if ( ( beta -> size [ 0 ] == yp -> size [ 0 ] ) && ( beta -> size [ 1 ] == yp -> size [ 1 ] ) ) { extentX = b_B [ 1 ] ; varargin_5_XWorldLimits_p = b_B [ 3 ] ; i = X_T -> size [ 0 ] * X_T -> size [ 1 ] ; X_T -> size [ 0 ] = beta -> size [ 0 ] ; X_T -> size [ 1 ] = beta -> size [ 1 ] ; gzgbsn15hy ( X_T , i ) ; k = beta -> size [ 0 ] * beta -> size [ 1 ] ; for ( i = 0 ; i < k ; i ++ ) { X_T -> data [ i ] = beta -> data [ i ] * extentX + yp -> data [ i ] * varargin_5_XWorldLimits_p ; } } else { ejfc1abzql ( X_T , b_B , beta , yp ) ; } pwmc1mnb1m ( & beta ) ; pwmc1mnb1m ( & yp ) ; k = x -> size [ 0 ] * x -> size [ 1 ] ; for ( i = 0 ; i < k ; i ++ ) { x -> data [ i ] = ( x -> data [ i ] - 0.5 ) + 0.5 ; } k = X_T -> size [ 0 ] * X_T -> size [ 1 ] ; for ( i = 0 ; i < k ; i ++ ) { X_T -> data [ i ] = ( X_T -> data [ i ] - 0.5 ) + 0.5 ; } k = x -> size [ 0 ] * x -> size [ 1 ] ; for ( i = 0 ; i < k ; i ++ ) { x -> data [ i ] += 3.0 ; } k = X_T -> size [ 0 ] * X_T -> size [ 1 ] ; for ( i = 0 ; i < k ; i ++ ) { X_T -> data [ i ] += 3.0 ; } for ( i = 0 ; i < 621 ; i ++ ) { rtB . inputImagePadded_mbvzarwird [ i ] = 0U ; rtB . inputImagePadded_mbvzarwird [ i + 42228 ] = 0U ; } for ( k = 0 ; k < 201 ; k ++ ) { rtB . inputImagePadded_mbvzarwird [ 207 * ( k + 3 ) ] = 0U ; rtB . inputImagePadded_mbvzarwird [ 207 * ( k + 3 ) + 204 ] = 0U ; rtB . inputImagePadded_mbvzarwird [ 207 * ( k + 3 ) + 1 ] = 0U ; rtB . inputImagePadded_mbvzarwird [ 207 * ( k + 3 ) + 205 ] = 0U ; rtB . inputImagePadded_mbvzarwird [ 207 * ( k + 3 ) + 2 ] = 0U ; rtB . inputImagePadded_mbvzarwird [ 207 * ( k + 3 ) + 206 ] = 0U ; memcpy ( & rtB . inputImagePadded_mbvzarwird [ k * 207 + 624 ] , & varargin_1 [ k * 201 ] , 201U * sizeof ( uint8_T ) ) ; } outputImage_size [ 0 ] = x -> size [ 0 ] ; outputImage_size [ 1 ] = x -> size [ 1 ] ; fillValues = 0U ; inputImageSize [ 0 ] = 207.0 ; inputImageSize [ 1 ] = 207.0 ; inputImageSize [ 2 ] = 1.0 ; outputImageSize [ 0 ] = x -> size [ 0 ] ; outputImageSize [ 1 ] = x -> size [ 1 ] ; imterp2d64f_uint8 ( & rtB . inputImagePadded_mbvzarwird [ 0 ] , & inputImageSize [ 0 ] , & X_T -> data [ 0 ] , & x -> data [ 0 ] , & outputImageSize [ 0 ] , 1.0 , true , & fillValues , & outputImage_data [ 0 ] ) ; pwmc1mnb1m ( & x ) ; pwmc1mnb1m ( & X_T ) ; } void MdlInitialize ( void ) { boolean_T tmp ; rtX . o3znemhc2a = rtP . mmrobotpose_theta0 ; rtX . b3xdnyzu1i = rtP . mmsimplerobot_x0 ; rtDW . i5bvacsh1c = ( rtInf ) ; rtDW . hj4s3vhbsm = ( rtInf ) ; rtDW . gqfi4xcbpq = ( rtInf ) ; rtDW . jf4thnpuad = ( rtInf ) ; rtX . o3b0zoxyg1 = rtP . mmsimplerobot_y0 ; rtDW . msu0usinuw = ( rtInf ) ; rtDW . a4phy4pqvq = ( rtInf ) ; rtDW . fvuqlob3jg = ( rtInf ) ; rtDW . b5ciq54a2a = ( rtInf ) ; rtDW . kw4mcnvapg = ( rtInf ) ; rtDW . dg4bndzwcf = ( rtInf ) ; rtDW . guxmnl3023 = ( rtInf ) ; rtDW . k4bunfh2cu = ( rtInf ) ; rtDW . hgyf2n5vgw = 0 ; rtDW . k00pa3laqh = 1U ; if ( ssIsFirstInitCond ( rtS ) ) { tmp = slIsRapidAcceleratorSimulating ( ) ; if ( tmp ) { tmp = ssGetGlobalInitialStatesAvailable ( rtS ) ; rtDW . k00pa3laqh = ( uint8_T ) ! tmp ; } else { rtDW . k00pa3laqh = 1U ; } } rtDW . n0ab4hkwjr = 0 ; rtDW . omatkykwmc = 1U ; if ( ssIsFirstInitCond ( rtS ) ) { tmp = slIsRapidAcceleratorSimulating ( ) ; if ( tmp ) { tmp = ssGetGlobalInitialStatesAvailable ( rtS ) ; rtDW . omatkykwmc = ( uint8_T ) ! tmp ; } else { rtDW . omatkykwmc = 1U ; } } rtDW . p34vnxg4cl = 0 ; rtDW . h2aulvebrm = 1U ; if ( ssIsFirstInitCond ( rtS ) ) { tmp = slIsRapidAcceleratorSimulating ( ) ; if ( tmp ) { tmp = ssGetGlobalInitialStatesAvailable ( rtS ) ; rtDW . h2aulvebrm = ( uint8_T ) ! tmp ; } else { rtDW . h2aulvebrm = 1U ; } } rtX . decrl0oxjd = rtP . Integrator1_IC ; rtX . brvdk5f5hy = rtP . Integrator1_IC_kg1uujsnot ; rtX . b414ta1ujl = rtP . Integrator_IC ; rtX . gjp2vw2s4j = rtP . Integrator_IC_ngb3lucrsz ; rtDW . boqo1kfngr = orjgypckdn ; rtDW . nmo21jm233 = orjgypckdn ; rtDW . jbz5db4uv3 = orjgypckdn ; rtDW . ihr0u5jxyq = false ; rtDW . jchleqhuy5 = false ; rtDW . iu2dpnxnxi = false ; rtDW . ddvsbh4eeb = false ; rtDW . nmgtdqicex = false ; rtDW . hkz1fvip5h = false ; rtDW . b41p410v44 = false ; rtDW . hcizcxtpa5 = false ; rtDW . kmgfkm3qi1 = 1.0 ; rtDW . of44i41wjh = 0.0 ; rtDW . anrkqgyd0y = 0.0 ; rtDW . c0ddl114m0 = 0.0 ; rtDW . bpv12jq0j2 = 0.0 ; rtDW . jngltzcitg = true ; rtDW . p1z00yunkl = orjgypckdn ; rtDW . ppafdi3a1m = orjgypckdn ; rtDW . cxaqlklp3z = 0U ; rtDW . pinldolpql = orjgypckdn ; rtB . iaho3wpxg5 = 0.0 ; rtB . fspxye1ya1 = 0.0 ; rtB . kbi5gtax1r = 0.0 ; rtB . nwh2ohbvkv = 0.0 ; rtB . dp50dq5tps = 0.0 ; rtB . hy1sdasjsw = 0.0 ; rtB . n504o31mpd = false ; rtDW . gcoa440zpp = 0.0 ; rtDW . fiug4ptcox = 0.0 ; rtDW . ftjkxzybsy = false ; rtDW . hrd2dtqf1n = false ; rtDW . dkcwlolqxl = false ; rtDW . egry1geo3t = false ; rtDW . k5vzkvexn5 = NextState_NONE ; rtDW . ei11pgnka4 = 0.0 ; rtDW . hryhffuttt = 0.0 ; rtDW . pkjabwswri = 0.0 ; rtDW . gz5an5grm2 = false ; rtDW . keotauvojf = false ; rtDW . hvlgcytolm = 0.0 ; rtDW . ahadgjvl0w = 0.0 ; rtDW . glguabnpzh = false ; rtDW . km1goje2r1 = false ; rtDW . azfivy5wqv = 0U ; rtDW . lhfc0ta5ml = fh2p20qa35 ; rtDW . p1x2oxibuy = orjgypckdn ; rtB . kzc2g5pqze = rtP . Out1_Y0 ; rtDW . nls3sblsfo = orjgypckdn ; rtDW . jcrrh2phtm = 25.0 ; rtDW . bymhg25233 = 0U ; rtDW . chcmzyq1nu = fh2p20qa35 ; rtDW . cpqsdojs4v = false ; rtDW . g3h3iifz4a = false ; rtDW . auf11wecna = false ; rtDW . eottp2wq2b = false ; rtDW . hv3cm0cioe = false ; rtDW . jtr2pdj40h = false ; rtDW . az214v0nqt = false ; rtDW . hivxqwy2wg = orjgypckdn ; rtDW . fffjpdz1bc = false ; rtDW . ctlazpcn1r = true ; rtDW . ibjaxusqtb = 0.0 ; rtDW . gpt4l3gxl0 = true ; rtDW . bhzxd4c0jb = 0.0 ; rtDW . bwmvjcjrxc = true ; rtDW . ag2o5lx0zx = orjgypckdn ; rtDW . kjbt4d23ke = orjgypckdn ; } void MdlStart ( void ) { { bool externalInputIsInDatasetFormat = false ; void * pISigstreamManager = rt_GetISigstreamManager ( rtS ) ; rtwISigstreamManagerGetInputIsInDatasetFormat ( pISigstreamManager , & externalInputIsInDatasetFormat ) ; if ( externalInputIsInDatasetFormat ) { } } { { { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "mm_autograde_M2_nice/Subsystem Reference1/TOF_FRONT" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiLabelU sigName = sdiGetLabelFromChars ( "" ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_CONTINUOUS ; SLSize sigDimsArray [ 1 ] = { ( SLSize ) 4 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; rtDW . ptoetb01hb . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , rt_dataMapInfo . mmi . InstanceMap . fullPath , "962e2783-9732-4d35-9fb9-1c28ef6bda26" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( rtDW . ptoetb01hb . AQHandles , hDT , & srcInfo ) ; if ( rtDW . ptoetb01hb . AQHandles ) { sdiSetSignalSampleTimeString ( rtDW . ptoetb01hb . AQHandles , "0.005" , 0.005 , ssGetTFinal ( rtS ) ) ; sdiSetSignalRefRate ( rtDW . ptoetb01hb . AQHandles , 0.0 ) ; sdiSetRunStartTime ( rtDW . ptoetb01hb . AQHandles , ssGetTaskTime ( rtS , 1 ) ) ; sdiAsyncRepoSetSignalExportSettings ( rtDW . ptoetb01hb . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( rtDW . ptoetb01hb . AQHandles , loggedName , origSigName , propName ) ; } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } { { { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "mm_autograde_M2_nice/Subsystem Reference1/TOF_LEFT" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiLabelU sigName = sdiGetLabelFromChars ( "" ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_CONTINUOUS ; SLSize sigDimsArray [ 1 ] = { ( SLSize ) 4 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; rtDW . fcrqtiosyn . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , rt_dataMapInfo . mmi . InstanceMap . fullPath , "955ce589-ceb1-457d-9c9f-458b605cc0d6" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( rtDW . fcrqtiosyn . AQHandles , hDT , & srcInfo ) ; if ( rtDW . fcrqtiosyn . AQHandles ) { sdiSetSignalSampleTimeString ( rtDW . fcrqtiosyn . AQHandles , "0.005" , 0.005 , ssGetTFinal ( rtS ) ) ; sdiSetSignalRefRate ( rtDW . fcrqtiosyn . AQHandles , 0.0 ) ; sdiSetRunStartTime ( rtDW . fcrqtiosyn . AQHandles , ssGetTaskTime ( rtS , 1 ) ) ; sdiAsyncRepoSetSignalExportSettings ( rtDW . fcrqtiosyn . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( rtDW . fcrqtiosyn . AQHandles , loggedName , origSigName , propName ) ; } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } { { { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "mm_autograde_M2_nice/Subsystem Reference1/TOF_RIGHT" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiLabelU sigName = sdiGetLabelFromChars ( "" ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_CONTINUOUS ; SLSize sigDimsArray [ 1 ] = { ( SLSize ) 4 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; rtDW . brzhetjznx . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , rt_dataMapInfo . mmi . InstanceMap . fullPath , "b927e7d6-98f6-4c75-9f97-001b2395aefe" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( rtDW . brzhetjznx . AQHandles , hDT , & srcInfo ) ; if ( rtDW . brzhetjznx . AQHandles ) { sdiSetSignalSampleTimeString ( rtDW . brzhetjznx . AQHandles , "0.005" , 0.005 , ssGetTFinal ( rtS ) ) ; sdiSetSignalRefRate ( rtDW . brzhetjznx . AQHandles , 0.0 ) ; sdiSetRunStartTime ( rtDW . brzhetjznx . AQHandles , ssGetTaskTime ( rtS , 1 ) ) ; sdiAsyncRepoSetSignalExportSettings ( rtDW . brzhetjznx . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( rtDW . brzhetjznx . AQHandles , loggedName , origSigName , propName ) ; } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } { { { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "Mux" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "Mux" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "mm_autograde_M2_nice/mm simple robot/To Workspace" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiLabelU sigName = sdiGetLabelFromChars ( "Mux" ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_CONTINUOUS ; SLSize sigDimsArray [ 1 ] = { ( SLSize ) 3 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; rtDW . bxw3wejwzq . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , rt_dataMapInfo . mmi . InstanceMap . fullPath , "0c80cc1e-b2eb-4a13-82e5-c46d59adfdfd" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( rtDW . bxw3wejwzq . AQHandles , hDT , & srcInfo ) ; if ( rtDW . bxw3wejwzq . AQHandles ) { sdiSetSignalSampleTimeString ( rtDW . bxw3wejwzq . AQHandles , "0.005" , 0.005 , ssGetTFinal ( rtS ) ) ; sdiSetSignalRefRate ( rtDW . bxw3wejwzq . AQHandles , 0.0 ) ; sdiSetRunStartTime ( rtDW . bxw3wejwzq . AQHandles , ssGetTaskTime ( rtS , 1 ) ) ; sdiAsyncRepoSetSignalExportSettings ( rtDW . bxw3wejwzq . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( rtDW . bxw3wejwzq . AQHandles , loggedName , origSigName , propName ) ; sdiAsyncRepoSetBlockPathDomain ( rtDW . bxw3wejwzq . AQHandles ) ; } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { { sdiLabelU varName = sdiGetLabelFromChars ( "trajectory" ) ; sdiRegisterWksVariable ( rtDW . bxw3wejwzq . AQHandles , varName , "timeseries" ) ; sdiFreeLabel ( varName ) ; } } } } } rtB . bm3zqotgwb [ 0 ] = 0.005 ; rtB . bm3zqotgwb [ 1 ] = 0.0 ; rtB . gc0h2fcjlf [ 0 ] = 0.005 ; rtB . gc0h2fcjlf [ 1 ] = 0.0 ; rtB . d5bexgg5ud [ 0 ] = 0.005 ; rtB . d5bexgg5ud [ 1 ] = 0.0 ; rtDW . cshvnu2qj4 = - 1 ; MdlInitialize ( ) ; } void MdlOutputs ( int_T tid ) { mgepjkjzts Rout ; nkmamamk5r xwsc [ 3 ] ; real_T bd1u2nprke [ 9 ] ; real_T bd1u2nprke_p [ 9 ] ; real_T catArgs [ 9 ] ; real_T tempR [ 9 ] ; real_T dt1kotclqk [ 4 ] ; real_T ltaoftfzmt [ 3 ] ; real_T v [ 3 ] ; real_T ebm4h2e2p2 [ 2 ] ; real_T bd1u2nprke_e ; real_T bd1u2nprke_i ; real_T bd1u2nprke_m ; real_T cth ; real_T h1q3iyvvtx ; real_T ltaoftfzmt_e ; real_T ltaoftfzmt_i ; real_T ltaoftfzmt_p ; real_T sth ; real_T * lastU ; int32_T ipiv [ 3 ] ; int32_T d_data ; int32_T ibmat ; int32_T iy ; int32_T partialTrueCount ; int8_T rtAction ; uint8_T mpvm ; static const int8_T c [ 3 ] = { 0 , 0 , 1 } ; static const real_T c_p [ 9 ] = { 0.5 , 0.5 , 0.5 , 101.0 , 101.0 , 101.0 , 201.5 , 201.5 , 201.5 } ; static const real_T d [ 9 ] = { 0.5 , 101.0 , 201.5 , 0.5 , 101.0 , 201.5 , 0.5 , 101.0 , 201.5 } ; lqgezxb0qr * simstruct ; int32_T d_size [ 2 ] ; srClearBC ( rtDW . anun1akbzt ) ; rtB . cngfn1wxw4 = rtX . o3znemhc2a ; rtDW . boqo1kfngr = orjgypckdn ; dt1kotclqk [ 3 ] = rtB . cngfn1wxw4 ; cth = muDoubleScalarCos ( dt1kotclqk [ 3 ] ) ; sth = muDoubleScalarSin ( dt1kotclqk [ 3 ] ) ; tempR [ 0 ] = ( 1.0 - cth ) * 0.0 + cth ; tempR [ 1 ] = ( 1.0 - cth ) * 0.0 - sth ; tempR [ 2 ] = ( 1.0 - cth ) * 0.0 + 0.0 * sth ; tempR [ 3 ] = ( 1.0 - cth ) * 0.0 + sth ; tempR [ 4 ] = ( 1.0 - cth ) * 0.0 + cth ; tempR [ 5 ] = ( 1.0 - cth ) * 0.0 - 0.0 * sth ; tempR [ 6 ] = ( 1.0 - cth ) * 0.0 - 0.0 * sth ; tempR [ 7 ] = ( 1.0 - cth ) * 0.0 + 0.0 * sth ; tempR [ 8 ] = ( 1.0 - cth ) + cth ; for ( iy = 0 ; iy < 3 ; iy ++ ) { bd1u2nprke [ iy ] = tempR [ iy * 3 ] ; bd1u2nprke [ iy + 3 ] = tempR [ iy * 3 + 1 ] ; bd1u2nprke [ iy + 6 ] = tempR [ iy * 3 + 2 ] ; } rtB . h4kspc310t = rtX . b3xdnyzu1i ; if ( ( rtDW . i5bvacsh1c >= ssGetT ( rtS ) ) && ( rtDW . hj4s3vhbsm >= ssGetT ( rtS ) ) ) { rtB . i1ks4nvn04 = 0.0 ; } else { h1q3iyvvtx = rtDW . i5bvacsh1c ; lastU = & rtDW . j0pj1cxjdn ; if ( rtDW . i5bvacsh1c < rtDW . hj4s3vhbsm ) { if ( rtDW . hj4s3vhbsm < ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . hj4s3vhbsm ; lastU = & rtDW . n3g3ymlzmr ; } } else if ( rtDW . i5bvacsh1c >= ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . hj4s3vhbsm ; lastU = & rtDW . n3g3ymlzmr ; } rtB . i1ks4nvn04 = ( rtB . h4kspc310t - * lastU ) / ( ssGetT ( rtS ) - h1q3iyvvtx ) ; } if ( ( rtDW . gqfi4xcbpq >= ssGetT ( rtS ) ) && ( rtDW . jf4thnpuad >= ssGetT ( rtS ) ) ) { cth = 0.0 ; } else { h1q3iyvvtx = rtDW . gqfi4xcbpq ; lastU = & rtDW . nltseoa5tf ; if ( rtDW . gqfi4xcbpq < rtDW . jf4thnpuad ) { if ( rtDW . jf4thnpuad < ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . jf4thnpuad ; lastU = & rtDW . mjsm4xz2fd ; } } else if ( rtDW . gqfi4xcbpq >= ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . jf4thnpuad ; lastU = & rtDW . mjsm4xz2fd ; } cth = ( rtB . i1ks4nvn04 - * lastU ) / ( ssGetT ( rtS ) - h1q3iyvvtx ) ; } rtB . gvkjqyfh5c = rtX . o3b0zoxyg1 ; if ( ( rtDW . msu0usinuw >= ssGetT ( rtS ) ) && ( rtDW . a4phy4pqvq >= ssGetT ( rtS ) ) ) { rtB . kxrvfu1ehv = 0.0 ; } else { h1q3iyvvtx = rtDW . msu0usinuw ; lastU = & rtDW . eb5ua2po2y ; if ( rtDW . msu0usinuw < rtDW . a4phy4pqvq ) { if ( rtDW . a4phy4pqvq < ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . a4phy4pqvq ; lastU = & rtDW . ht4sfrmguj ; } } else if ( rtDW . msu0usinuw >= ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . a4phy4pqvq ; lastU = & rtDW . ht4sfrmguj ; } rtB . kxrvfu1ehv = ( rtB . gvkjqyfh5c - * lastU ) / ( ssGetT ( rtS ) - h1q3iyvvtx ) ; } if ( ( rtDW . fvuqlob3jg >= ssGetT ( rtS ) ) && ( rtDW . b5ciq54a2a >= ssGetT ( rtS ) ) ) { sth = 0.0 ; } else { h1q3iyvvtx = rtDW . fvuqlob3jg ; lastU = & rtDW . ghpi3etgoe ; if ( rtDW . fvuqlob3jg < rtDW . b5ciq54a2a ) { if ( rtDW . b5ciq54a2a < ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . b5ciq54a2a ; lastU = & rtDW . as3jc4aixp ; } } else if ( rtDW . fvuqlob3jg >= ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . b5ciq54a2a ; lastU = & rtDW . as3jc4aixp ; } sth = ( rtB . kxrvfu1ehv - * lastU ) / ( ssGetT ( rtS ) - h1q3iyvvtx ) ; } if ( ( rtDW . kw4mcnvapg >= ssGetT ( rtS ) ) && ( rtDW . dg4bndzwcf >= ssGetT ( rtS ) ) ) { rtB . lsr13h5kid = 0.0 ; } else { h1q3iyvvtx = rtDW . kw4mcnvapg ; lastU = & rtDW . hekbx12zjf ; if ( rtDW . kw4mcnvapg < rtDW . dg4bndzwcf ) { if ( rtDW . dg4bndzwcf < ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . dg4bndzwcf ; lastU = & rtDW . bsz2i3x1zz ; } } else if ( rtDW . kw4mcnvapg >= ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . dg4bndzwcf ; lastU = & rtDW . bsz2i3x1zz ; } rtB . lsr13h5kid = ( rtB . cngfn1wxw4 - * lastU ) / ( ssGetT ( rtS ) - h1q3iyvvtx ) ; } rtB . ehm3yytxoa [ 0 ] = rtP . Constant1_Value [ 0 ] ; rtB . ehm3yytxoa [ 1 ] = rtP . Constant1_Value [ 1 ] ; rtB . ehm3yytxoa [ 2 ] = rtB . lsr13h5kid ; if ( ( rtDW . guxmnl3023 >= ssGetT ( rtS ) ) && ( rtDW . k4bunfh2cu >= ssGetT ( rtS ) ) ) { h1q3iyvvtx = 0.0 ; } else { h1q3iyvvtx = rtDW . guxmnl3023 ; lastU = & rtDW . mkaulxhvv5 ; if ( rtDW . guxmnl3023 < rtDW . k4bunfh2cu ) { if ( rtDW . k4bunfh2cu < ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . k4bunfh2cu ; lastU = & rtDW . omd2l4th2w ; } } else if ( rtDW . guxmnl3023 >= ssGetT ( rtS ) ) { h1q3iyvvtx = rtDW . k4bunfh2cu ; lastU = & rtDW . omd2l4th2w ; } h1q3iyvvtx = ( rtB . lsr13h5kid - * lastU ) / ( ssGetT ( rtS ) - h1q3iyvvtx ) ; } rtDW . nmo21jm233 = orjgypckdn ; v [ 0 ] = 0.0 ; v [ 1 ] = 0.0 ; v [ 2 ] = 0.0 ; for ( iy = 0 ; iy < 3 ; iy ++ ) { ltaoftfzmt_p = rtP . simstruct . timu [ iy ] ; v [ 0 ] += bd1u2nprke [ 3 * iy ] * ltaoftfzmt_p ; v [ 1 ] += bd1u2nprke [ 3 * iy + 1 ] * ltaoftfzmt_p ; v [ 2 ] += bd1u2nprke [ 3 * iy + 2 ] * ltaoftfzmt_p ; bd1u2nprke_e = 0.0 ; bd1u2nprke_i = 0.0 ; bd1u2nprke_m = 0.0 ; for ( ibmat = 0 ; ibmat < 3 ; ibmat ++ ) { ltaoftfzmt_p = rtP . simstruct . Rimu [ 3 * iy + ibmat ] ; bd1u2nprke_e += bd1u2nprke [ 3 * ibmat ] * ltaoftfzmt_p ; bd1u2nprke_i += bd1u2nprke [ 3 * ibmat + 1 ] * ltaoftfzmt_p ; bd1u2nprke_m += bd1u2nprke [ 3 * ibmat + 2 ] * ltaoftfzmt_p ; } catArgs [ 3 * iy + 2 ] = bd1u2nprke_m ; catArgs [ 3 * iy + 1 ] = bd1u2nprke_i ; catArgs [ 3 * iy ] = bd1u2nprke_e ; } ltaoftfzmt [ 0 ] = rtP . Constant1_Value [ 1 ] * v [ 2 ] - v [ 1 ] * rtB . lsr13h5kid ; ltaoftfzmt [ 1 ] = v [ 0 ] * rtB . lsr13h5kid - rtP . Constant1_Value [ 0 ] * v [ 2 ] ; ltaoftfzmt [ 2 ] = rtP . Constant1_Value [ 0 ] * v [ 1 ] - v [ 0 ] * rtP . Constant1_Value [ 1 ] ; ltaoftfzmt_p = ltaoftfzmt [ 2 ] ; bd1u2nprke_e = ltaoftfzmt [ 1 ] ; bd1u2nprke_i = ltaoftfzmt [ 0 ] ; bd1u2nprke_m = ltaoftfzmt [ 2 ] ; ltaoftfzmt_e = ltaoftfzmt [ 1 ] ; ltaoftfzmt_i = ltaoftfzmt [ 0 ] ; ltaoftfzmt [ 0 ] = ( ( rtP . Constant1_Value [ 1 ] * v [ 2 ] - v [ 1 ] * h1q3iyvvtx ) + ( rtP . Constant1_Value [ 1 ] * ltaoftfzmt_p - bd1u2nprke_e * rtB . lsr13h5kid ) ) + cth ; ltaoftfzmt [ 1 ] = ( ( v [ 0 ] * h1q3iyvvtx - rtP . Constant1_Value [ 0 ] * v [ 2 ] ) + ( bd1u2nprke_i * rtB . lsr13h5kid - rtP . Constant1_Value [ 0 ] * bd1u2nprke_m ) ) + sth ; ltaoftfzmt [ 2 ] = ( ( rtP . Constant1_Value [ 0 ] * v [ 1 ] - v [ 0 ] * rtP . Constant1_Value [ 1 ] ) + ( rtP . Constant1_Value [ 0 ] * ltaoftfzmt_e - ltaoftfzmt_i * rtP . Constant1_Value [ 1 ] ) ) + rtP . Constant_Value_e5jcotvvny ; ltaoftfzmt [ 2 ] += 9.81 ; cpvtu4asbr ( catArgs , bd1u2nprke ) ; rtB . k04rua40z0 [ 0 ] = 0.0 ; rtB . k04rua40z0 [ 1 ] = 0.0 ; rtB . k04rua40z0 [ 2 ] = 0.0 ; cth = rtB . k04rua40z0 [ 0 ] ; sth = rtB . k04rua40z0 [ 1 ] ; h1q3iyvvtx = rtB . k04rua40z0 [ 2 ] ; for ( iy = 0 ; iy < 3 ; iy ++ ) { ltaoftfzmt_p = ltaoftfzmt [ iy ] ; cth += bd1u2nprke [ 3 * iy ] * ltaoftfzmt_p ; sth += bd1u2nprke [ 3 * iy + 1 ] * ltaoftfzmt_p ; h1q3iyvvtx += bd1u2nprke [ 3 * iy + 2 ] * ltaoftfzmt_p ; } rtB . k04rua40z0 [ 2 ] = h1q3iyvvtx ; rtB . k04rua40z0 [ 1 ] = sth ; rtB . k04rua40z0 [ 0 ] = cth ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtB . dv5fmxftb2 = ( ( rtP . LowPassFilterDiscreteorContinuous3_T - rtB . bm3zqotgwb [ 0 ] <= rtP . Constant_Value ) && rtB . cngravbh2r ) ; } rtDW . jbz5db4uv3 = orjgypckdn ; v [ 0 ] = rtB . h4kspc310t ; v [ 1 ] = rtB . gvkjqyfh5c ; v [ 2 ] = rtB . cngfn1wxw4 ; bd1u2nprke [ 0 ] = muDoubleScalarCos ( v [ 2 ] ) ; bd1u2nprke [ 3 ] = - muDoubleScalarSin ( v [ 2 ] ) ; bd1u2nprke [ 6 ] = v [ 0 ] ; bd1u2nprke [ 1 ] = muDoubleScalarSin ( v [ 2 ] ) ; bd1u2nprke [ 4 ] = muDoubleScalarCos ( v [ 2 ] ) ; bd1u2nprke [ 7 ] = v [ 1 ] ; tempR [ 0 ] = muDoubleScalarCos ( rtP . simstruct . tofposes [ 6 ] ) ; tempR [ 3 ] = - muDoubleScalarSin ( rtP . simstruct . tofposes [ 6 ] ) ; tempR [ 6 ] = rtP . simstruct . tofposes [ 0 ] ; tempR [ 1 ] = muDoubleScalarSin ( rtP . simstruct . tofposes [ 6 ] ) ; tempR [ 4 ] = muDoubleScalarCos ( rtP . simstruct . tofposes [ 6 ] ) ; tempR [ 7 ] = rtP . simstruct . tofposes [ 3 ] ; for ( iy = 0 ; iy < 3 ; iy ++ ) { rtAction = c [ iy ] ; bd1u2nprke [ 3 * iy + 2 ] = rtAction ; tempR [ 3 * iy + 2 ] = rtAction ; catArgs [ 3 * iy ] = 0.0 ; catArgs [ 3 * iy + 1 ] = 0.0 ; catArgs [ 3 * iy + 2 ] = 0.0 ; } cth = 0.0 ; sth = 0.0 ; h1q3iyvvtx = 0.0 ; for ( iy = 0 ; iy < 3 ; iy ++ ) { bd1u2nprke_e = catArgs [ 3 * iy ] ; bd1u2nprke_i = catArgs [ 3 * iy + 1 ] ; bd1u2nprke_m = catArgs [ 3 * iy + 2 ] ; for ( ibmat = 0 ; ibmat < 3 ; ibmat ++ ) { ltaoftfzmt_p = tempR [ 3 * iy + ibmat ] ; bd1u2nprke_e += bd1u2nprke [ 3 * ibmat ] * ltaoftfzmt_p ; bd1u2nprke_i += bd1u2nprke [ 3 * ibmat + 1 ] * ltaoftfzmt_p ; bd1u2nprke_m += bd1u2nprke [ 3 * ibmat + 2 ] * ltaoftfzmt_p ; } catArgs [ 3 * iy + 2 ] = bd1u2nprke_m ; catArgs [ 3 * iy + 1 ] = bd1u2nprke_i ; catArgs [ 3 * iy ] = bd1u2nprke_e ; ibmat = c [ iy ] ; cth += catArgs [ 3 * iy ] * ( real_T ) ibmat ; sth += catArgs [ 3 * iy + 1 ] * ( real_T ) ibmat ; h1q3iyvvtx += catArgs [ 3 * iy + 2 ] * ( real_T ) ibmat ; } v [ 2 ] = h1q3iyvvtx ; v [ 1 ] = sth ; v [ 0 ] = cth ; xwsc [ 0 ] . f1 [ 0 ] = v [ 0 ] / v [ 2 ] ; xwsc [ 0 ] . f1 [ 1 ] = v [ 1 ] / v [ 2 ] ; for ( iy = 0 ; iy < 1491 ; iy ++ ) { rtB . mpv [ 3 * iy ] = rtP . simstruct . tofspts [ iy ] ; rtB . mpv [ 3 * iy + 1 ] = 0.0 ; rtB . mpv [ 3 * iy + 2 ] = 1.0 ; } for ( iy = 0 ; iy < 3 ; iy ++ ) { bd1u2nprke_e = 0.0 ; bd1u2nprke_i = 0.0 ; bd1u2nprke_m = 0.0 ; for ( ibmat = 0 ; ibmat < 3 ; ibmat ++ ) { ltaoftfzmt_p = tempR [ 3 * iy + ibmat ] ; bd1u2nprke_e += bd1u2nprke [ 3 * ibmat ] * ltaoftfzmt_p ; bd1u2nprke_i += bd1u2nprke [ 3 * ibmat + 1 ] * ltaoftfzmt_p ; bd1u2nprke_m += bd1u2nprke [ 3 * ibmat + 2 ] * ltaoftfzmt_p ; } catArgs [ 3 * iy + 2 ] = bd1u2nprke_m ; catArgs [ 3 * iy + 1 ] = bd1u2nprke_i ; catArgs [ 3 * iy ] = bd1u2nprke_e ; } ekw23p03z3 ( catArgs , rtB . mpv , rtB . xwh ) ; for ( iy = 0 ; iy < 1491 ; iy ++ ) { cth = rtB . xwh [ 3 * iy + 2 ] ; rtB . xwc [ 0 ] . f1 [ iy << 1 ] = rtB . xwh [ 3 * iy ] / cth ; rtB . xwc [ 0 ] . f1 [ ( iy << 1 ) + 1 ] = rtB . xwh [ 3 * iy + 1 ] / cth ; } tempR [ 0 ] = muDoubleScalarCos ( rtP . simstruct . tofposes [ 7 ] ) ; tempR [ 3 ] = - muDoubleScalarSin ( rtP . simstruct . tofposes [ 7 ] ) ; tempR [ 6 ] = rtP . simstruct . tofposes [ 1 ] ; tempR [ 1 ] = muDoubleScalarSin ( rtP . simstruct . tofposes [ 7 ] ) ; tempR [ 4 ] = muDoubleScalarCos ( rtP . simstruct . tofposes [ 7 ] ) ; tempR [ 7 ] = rtP . simstruct . tofposes [ 4 ] ; cth = 0.0 ; sth = 0.0 ; h1q3iyvvtx = 0.0 ; for ( iy = 0 ; iy < 3 ; iy ++ ) { tempR [ 3 * iy + 2 ] = c [ iy ] ; bd1u2nprke_e = 0.0 ; bd1u2nprke_i = 0.0 ; bd1u2nprke_m = 0.0 ; for ( ibmat = 0 ; ibmat < 3 ; ibmat ++ ) { ltaoftfzmt_p = tempR [ 3 * iy + ibmat ] ; bd1u2nprke_e += bd1u2nprke [ 3 * ibmat ] * ltaoftfzmt_p ; bd1u2nprke_i += bd1u2nprke [ 3 * ibmat + 1 ] * ltaoftfzmt_p ; bd1u2nprke_m += bd1u2nprke [ 3 * ibmat + 2 ] * ltaoftfzmt_p ; } catArgs [ 3 * iy + 2 ] = bd1u2nprke_m ; catArgs [ 3 * iy + 1 ] = bd1u2nprke_i ; catArgs [ 3 * iy ] = bd1u2nprke_e ; ibmat = c [ iy ] ; cth += catArgs [ 3 * iy ] * ( real_T ) ibmat ; sth += catArgs [ 3 * iy + 1 ] * ( real_T ) ibmat ; h1q3iyvvtx += catArgs [ 3 * iy + 2 ] * ( real_T ) ibmat ; } v [ 2 ] = h1q3iyvvtx ; v [ 1 ] = sth ; v [ 0 ] = cth ; xwsc [ 1 ] . f1 [ 0 ] = v [ 0 ] / v [ 2 ] ; xwsc [ 1 ] . f1 [ 1 ] = v [ 1 ] / v [ 2 ] ; for ( iy = 0 ; iy < 3 ; iy ++ ) { bd1u2nprke_e = 0.0 ; bd1u2nprke_i = 0.0 ; bd1u2nprke_m = 0.0 ; for ( ibmat = 0 ; ibmat < 3 ; ibmat ++ ) { ltaoftfzmt_p = tempR [ 3 * iy + ibmat ] ; bd1u2nprke_e += bd1u2nprke [ 3 * ibmat ] * ltaoftfzmt_p ; bd1u2nprke_i += bd1u2nprke [ 3 * ibmat + 1 ] * ltaoftfzmt_p ; bd1u2nprke_m += bd1u2nprke [ 3 * ibmat + 2 ] * ltaoftfzmt_p ; } catArgs [ 3 * iy + 2 ] = bd1u2nprke_m ; catArgs [ 3 * iy + 1 ] = bd1u2nprke_i ; catArgs [ 3 * iy ] = bd1u2nprke_e ; } ekw23p03z3 ( catArgs , rtB . mpv , rtB . xwh ) ; for ( iy = 0 ; iy < 1491 ; iy ++ ) { cth = rtB . xwh [ 3 * iy + 2 ] ; rtB . xwc [ 1 ] . f1 [ iy << 1 ] = rtB . xwh [ 3 * iy ] / cth ; rtB . xwc [ 1 ] . f1 [ ( iy << 1 ) + 1 ] = rtB . xwh [ 3 * iy + 1 ] / cth ; } tempR [ 0 ] = muDoubleScalarCos ( rtP . simstruct . tofposes [ 8 ] ) ; tempR [ 3 ] = - muDoubleScalarSin ( rtP . simstruct . tofposes [ 8 ] ) ; tempR [ 6 ] = rtP . simstruct . tofposes [ 2 ] ; tempR [ 1 ] = muDoubleScalarSin ( rtP . simstruct . tofposes [ 8 ] ) ; tempR [ 4 ] = muDoubleScalarCos ( rtP . simstruct . tofposes [ 8 ] ) ; tempR [ 7 ] = rtP . simstruct . tofposes [ 5 ] ; for ( iy = 0 ; iy < 3 ; iy ++ ) { tempR [ 3 * iy + 2 ] = c [ iy ] ; bd1u2nprke_e = 0.0 ; bd1u2nprke_i = 0.0 ; bd1u2nprke_m = 0.0 ; for ( ibmat = 0 ; ibmat < 3 ; ibmat ++ ) { ltaoftfzmt_p = tempR [ 3 * iy + ibmat ] ; bd1u2nprke_e += bd1u2nprke [ 3 * ibmat ] * ltaoftfzmt_p ; bd1u2nprke_i += bd1u2nprke [ 3 * ibmat + 1 ] * ltaoftfzmt_p ; bd1u2nprke_m += bd1u2nprke [ 3 * ibmat + 2 ] * ltaoftfzmt_p ; } catArgs [ 3 * iy + 2 ] = bd1u2nprke_m ; catArgs [ 3 * iy + 1 ] = bd1u2nprke_i ; catArgs [ 3 * iy ] = bd1u2nprke_e ; v [ iy ] = 0.0 ; } for ( iy = 0 ; iy < 3 ; iy ++ ) { ibmat = c [ iy ] ; v [ 0 ] += catArgs [ 3 * iy ] * ( real_T ) ibmat ; v [ 1 ] += catArgs [ 3 * iy + 1 ] * ( real_T ) ibmat ; v [ 2 ] += catArgs [ 3 * iy + 2 ] * ( real_T ) ibmat ; bd1u2nprke_e = 0.0 ; bd1u2nprke_i = 0.0 ; bd1u2nprke_m = 0.0 ; for ( ibmat = 0 ; ibmat < 3 ; ibmat ++ ) { ltaoftfzmt_p = tempR [ 3 * iy + ibmat ] ; bd1u2nprke_e += bd1u2nprke [ 3 * ibmat ] * ltaoftfzmt_p ; bd1u2nprke_i += bd1u2nprke [ 3 * ibmat + 1 ] * ltaoftfzmt_p ; bd1u2nprke_m += bd1u2nprke [ 3 * ibmat + 2 ] * ltaoftfzmt_p ; } bd1u2nprke_p [ 3 * iy + 2 ] = bd1u2nprke_m ; bd1u2nprke_p [ 3 * iy + 1 ] = bd1u2nprke_i ; bd1u2nprke_p [ 3 * iy ] = bd1u2nprke_e ; } ekw23p03z3 ( bd1u2nprke_p , rtB . mpv , rtB . xwh ) ; for ( iy = 0 ; iy < 1491 ; iy ++ ) { ibmat = iy << 1 ; cth = rtB . xwh [ 3 * iy + 2 ] ; rtB . b_b [ ibmat ] = cth ; rtB . b_b [ ibmat + 1 ] = cth ; rtB . xwc [ 2 ] . f1 [ iy << 1 ] = rtB . xwh [ 3 * iy ] / cth ; rtB . xwc [ 2 ] . f1 [ ( iy << 1 ) + 1 ] = rtB . xwh [ 3 * iy + 1 ] / cth ; } for ( iy = 0 ; iy < 2982 ; iy ++ ) { rtB . xwa [ iy ] = rtB . xwc [ 0 ] . f1 [ iy ] ; rtB . xwa [ iy + 2982 ] = rtB . xwc [ 1 ] . f1 [ iy ] ; rtB . xwa [ iy + 5964 ] = rtB . xwc [ 2 ] . f1 [ iy ] ; } for ( iy = 0 ; iy < 8946 ; iy ++ ) { rtB . xwa [ iy ] = muDoubleScalarRound ( rtP . simstruct . mapres * rtB . xwa [ iy ] ) + 1.0 ; } for ( iy = 0 ; iy < 4473 ; iy ++ ) { cth = rtB . xwa [ iy << 1 ] ; sth = rtB . xwa [ ( iy << 1 ) + 1 ] ; rtB . ii [ iy ] = ( ( cth >= 1.0 ) && ( cth <= 601.0 ) && ( sth >= 1.0 ) && ( sth <= 400.0 ) ) ; rtB . mpv [ iy ] = 0.0 ; } partialTrueCount = 0 ; ibmat = 0 ; for ( iy = 0 ; iy < 4473 ; iy ++ ) { if ( rtB . ii [ iy ] ) { rtB . tmp_data [ partialTrueCount ] = ( int16_T ) iy ; partialTrueCount ++ ; ibmat ++ ; } } partialTrueCount = 0 ; for ( iy = 0 ; iy < 4473 ; iy ++ ) { if ( rtB . ii [ iy ] ) { rtB . tmp_data_cl54gopm0x [ partialTrueCount ] = ( int16_T ) iy ; partialTrueCount ++ ; } } partialTrueCount = ibmat ; for ( iy = 0 ; iy < partialTrueCount ; iy ++ ) { ibmat = rtB . tmp_data_cl54gopm0x [ iy ] ; rtB . mpv [ rtB . tmp_data [ iy ] ] = rtP . simstruct . mapimfud [ ( ( ( int32_T ) rtB . xwa [ ibmat << 1 ] - 1 ) * 400 + ( int32_T ) rtB . xwa [ ( ibmat << 1 ) + 1 ] ) - 1 ] ; } rtB . mpugsvqgyh [ 0 ] = ( rtNaN ) ; for ( iy = 0 ; iy < 1491 ; iy ++ ) { mpvm = ( uint8_T ) rtB . mpv [ iy ] ; rtB . mpvm_kkiq3xxxve [ 3 * iy ] = mpvm ; rtB . mpvm_kkiq3xxxve [ 3 * iy + 1 ] = ( uint8_T ) rtB . mpv [ iy + 1491 ] ; rtB . mpvm_kkiq3xxxve [ 3 * iy + 2 ] = ( uint8_T ) rtB . mpv [ iy + 2982 ] ; rtB . mpvm [ iy ] = mpvm ; } eyo0q11x42 ( rtB . mpvm , & d_data , d_size ) ; if ( d_size [ 1 ] != 0 ) { iy = d_data ; cth = rtB . xwc [ 0 ] . f1 [ ( iy - 1 ) << 1 ] - xwsc [ 0 ] . f1 [ 0 ] ; sth = cth * cth ; cth = rtB . xwc [ 0 ] . f1 [ ( ( iy - 1 ) << 1 ) + 1 ] - xwsc [ 0 ] . f1 [ 1 ] ; rtB . mpugsvqgyh [ 0 ] = muDoubleScalarSqrt ( cth * cth + sth ) ; } rtB . mpugsvqgyh [ 1 ] = ( rtNaN ) ; for ( iy = 0 ; iy < 1491 ; iy ++ ) { rtB . mpvm [ iy ] = rtB . mpvm_kkiq3xxxve [ 3 * iy + 1 ] ; } eyo0q11x42 ( rtB . mpvm , & d_data , d_size ) ; if ( d_size [ 1 ] != 0 ) { iy = d_data ; cth = rtB . xwc [ 1 ] . f1 [ ( iy - 1 ) << 1 ] - xwsc [ 1 ] . f1 [ 0 ] ; sth = cth * cth ; cth = rtB . xwc [ 1 ] . f1 [ ( ( iy - 1 ) << 1 ) + 1 ] - xwsc [ 1 ] . f1 [ 1 ] ; rtB . mpugsvqgyh [ 1 ] = muDoubleScalarSqrt ( cth * cth + sth ) ; } rtB . mpugsvqgyh [ 2 ] = ( rtNaN ) ; for ( iy = 0 ; iy < 1491 ; iy ++ ) { rtB . mpvm [ iy ] = rtB . mpvm_kkiq3xxxve [ 3 * iy + 2 ] ; } eyo0q11x42 ( rtB . mpvm , & d_data , d_size ) ; if ( d_size [ 1 ] != 0 ) { iy = d_data - 1 ; cth = rtB . xwh [ 3 * iy ] / rtB . b_b [ iy << 1 ] - v [ 0 ] / v [ 2 ] ; sth = cth * cth ; cth = rtB . xwh [ 3 * iy + 1 ] / rtB . b_b [ ( iy << 1 ) + 1 ] - v [ 1 ] / v [ 2 ] ; rtB . mpugsvqgyh [ 2 ] = muDoubleScalarSqrt ( cth * cth + sth ) ; } for ( iy = 0 ; iy < 3 ; iy ++ ) { if ( muDoubleScalarIsNaN ( rtB . mpugsvqgyh [ iy ] ) ) { rtB . mpugsvqgyh [ iy ] = 8.0 ; } } rtB . kwftyjyxpv [ 0 ] = rtB . mpugsvqgyh [ 0 ] ; rtB . kwftyjyxpv [ 1 ] = rtB . mpugsvqgyh [ 1 ] ; rtB . kwftyjyxpv [ 2 ] = rtB . mpugsvqgyh [ 2 ] ; rtB . ewf4owjito = rtP . LowPassFilterDiscreteorContinuous3_K * rtB . kwftyjyxpv [ 0 ] ; rtB . ivhyg3ka2t = rtP . LowPassFilterDiscreteorContinuous4_K * rtB . kwftyjyxpv [ 1 ] ; rtB . geack2hgej = rtP . LowPassFilterDiscreteorContinuous5_K * rtB . kwftyjyxpv [ 2 ] ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { if ( rtDW . k00pa3laqh != 0 ) { rtDW . e2tyz0qrrq = rtB . ewf4owjito ; if ( rtDW . e2tyz0qrrq > rtP . Integrator_UpperSat ) { rtDW . e2tyz0qrrq = rtP . Integrator_UpperSat ; } else if ( rtDW . e2tyz0qrrq < rtP . Integrator_LowerSat ) { rtDW . e2tyz0qrrq = rtP . Integrator_LowerSat ; } } if ( rtB . dv5fmxftb2 || ( rtDW . hgyf2n5vgw != 0 ) ) { rtDW . e2tyz0qrrq = rtB . ewf4owjito ; if ( rtDW . e2tyz0qrrq > rtP . Integrator_UpperSat ) { rtDW . e2tyz0qrrq = rtP . Integrator_UpperSat ; } else if ( rtDW . e2tyz0qrrq < rtP . Integrator_LowerSat ) { rtDW . e2tyz0qrrq = rtP . Integrator_LowerSat ; } } if ( rtDW . e2tyz0qrrq > rtP . Saturation_UpperSat ) { rtB . euqty000s5 = rtP . Saturation_UpperSat ; } else if ( rtDW . e2tyz0qrrq < rtP . Saturation_LowerSat ) { rtB . euqty000s5 = rtP . Saturation_LowerSat ; } else { rtB . euqty000s5 = rtDW . e2tyz0qrrq ; } rtB . hez31ivcnc = ( ( rtP . LowPassFilterDiscreteorContinuous4_T - rtB . gc0h2fcjlf [ 0 ] <= rtP . Constant_Value_ofajz0vmqk ) && rtB . caujwou1jk ) ; if ( rtDW . omatkykwmc != 0 ) { rtDW . dupakdsnzz = rtB . ivhyg3ka2t ; if ( rtDW . dupakdsnzz > rtP . Integrator_UpperSat_kzv3sf2wkn ) { rtDW . dupakdsnzz = rtP . Integrator_UpperSat_kzv3sf2wkn ; } else if ( rtDW . dupakdsnzz < rtP . Integrator_LowerSat_et0vhzjblr ) { rtDW . dupakdsnzz = rtP . Integrator_LowerSat_et0vhzjblr ; } } if ( rtB . hez31ivcnc || ( rtDW . n0ab4hkwjr != 0 ) ) { rtDW . dupakdsnzz = rtB . ivhyg3ka2t ; if ( rtDW . dupakdsnzz > rtP . Integrator_UpperSat_kzv3sf2wkn ) { rtDW . dupakdsnzz = rtP . Integrator_UpperSat_kzv3sf2wkn ; } else if ( rtDW . dupakdsnzz < rtP . Integrator_LowerSat_et0vhzjblr ) { rtDW . dupakdsnzz = rtP . Integrator_LowerSat_et0vhzjblr ; } } if ( rtDW . dupakdsnzz > rtP . Saturation_UpperSat_lqq4s3fwjp ) { rtB . o4oyjbghkn = rtP . Saturation_UpperSat_lqq4s3fwjp ; } else if ( rtDW . dupakdsnzz < rtP . Saturation_LowerSat_az2le0w5qs ) { rtB . o4oyjbghkn = rtP . Saturation_LowerSat_az2le0w5qs ; } else { rtB . o4oyjbghkn = rtDW . dupakdsnzz ; } rtB . pbnizhjvzo = ( ( rtP . LowPassFilterDiscreteorContinuous5_T - rtB . d5bexgg5ud [ 0 ] <= rtP . Constant_Value_iweutw4dc2 ) && rtB . ntxg1addth ) ; if ( rtDW . h2aulvebrm != 0 ) { rtDW . a5hvpj25th = rtB . geack2hgej ; if ( rtDW . a5hvpj25th > rtP . Integrator_UpperSat_fgmadlykzp ) { rtDW . a5hvpj25th = rtP . Integrator_UpperSat_fgmadlykzp ; } else if ( rtDW . a5hvpj25th < rtP . Integrator_LowerSat_kbaak3f5xe ) { rtDW . a5hvpj25th = rtP . Integrator_LowerSat_kbaak3f5xe ; } } if ( rtB . pbnizhjvzo || ( rtDW . p34vnxg4cl != 0 ) ) { rtDW . a5hvpj25th = rtB . geack2hgej ; if ( rtDW . a5hvpj25th > rtP . Integrator_UpperSat_fgmadlykzp ) { rtDW . a5hvpj25th = rtP . Integrator_UpperSat_fgmadlykzp ; } else if ( rtDW . a5hvpj25th < rtP . Integrator_LowerSat_kbaak3f5xe ) { rtDW . a5hvpj25th = rtP . Integrator_LowerSat_kbaak3f5xe ; } } if ( rtDW . a5hvpj25th > rtP . Saturation_UpperSat_my3br2vs03 ) { rtB . aw5fvfkl4k = rtP . Saturation_UpperSat_my3br2vs03 ; } else if ( rtDW . a5hvpj25th < rtP . Saturation_LowerSat_awul2wab42 ) { rtB . aw5fvfkl4k = rtP . Saturation_LowerSat_awul2wab42 ; } else { rtB . aw5fvfkl4k = rtDW . a5hvpj25th ; } } rtB . jnbt4dp1zd = rtX . decrl0oxjd ; rtB . pvl2fqbdnb [ 0 ] = muDoubleScalarRem ( muDoubleScalarFloor ( rtP . mmwheelencoders_ticsperrev * 2.0 * muDoubleScalarRem ( rtX . brvdk5f5hy / rtP . Constant_Value_lr4ms5o4l0 , rtP . Constant1_Value_ddcl5gh2ak ) ) , rtP . Constant2_Value ) ; rtB . pvl2fqbdnb [ 1 ] = muDoubleScalarRem ( muDoubleScalarFloor ( rtP . mmwheelencoders_ticsperrev * 2.0 * muDoubleScalarRem ( rtX . b414ta1ujl / rtP . Constant_Value_lr4ms5o4l0 , rtP . Constant1_Value_ddcl5gh2ak ) ) , rtP . Constant2_Value ) ; rtB . c3f5my0yba [ 0 ] = rtP . Gain4_Gain * rtB . pvl2fqbdnb [ 0 ] ; rtB . c3f5my0yba [ 1 ] = rtP . Gain4_Gain * rtB . pvl2fqbdnb [ 1 ] ; if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtDW . p1z00yunkl = orjgypckdn ; if ( ! rtDW . hcizcxtpa5 ) { rtDW . ihr0u5jxyq = true ; cth = rtB . c3f5my0yba [ 0 ] ; sth = rtB . c3f5my0yba [ 1 ] ; for ( iy = 0 ; iy < 7 ; iy ++ ) { rtDW . m5xqkkdrpe [ iy ] = cth ; rtDW . dlac4no1kf [ iy ] = sth ; } rtDW . jchleqhuy5 = true ; rtDW . iu2dpnxnxi = true ; rtDW . ddvsbh4eeb = true ; rtDW . nmgtdqicex = true ; rtDW . hkz1fvip5h = true ; rtDW . b41p410v44 = true ; rtDW . hcizcxtpa5 = true ; } rtDW . m5xqkkdrpe [ ( int32_T ) rtDW . kmgfkm3qi1 - 1 ] = rtB . c3f5my0yba [ 0 ] ; rtDW . dlac4no1kf [ ( int32_T ) rtDW . kmgfkm3qi1 - 1 ] = rtB . c3f5my0yba [ 1 ] ; rtDW . kmgfkm3qi1 ++ ; if ( rtDW . kmgfkm3qi1 > 7.0 ) { rtDW . kmgfkm3qi1 = 1.0 ; } cth = rtDW . m5xqkkdrpe [ 0 ] ; sth = rtDW . dlac4no1kf [ 0 ] ; for ( iy = 0 ; iy < 6 ; iy ++ ) { cth += rtDW . m5xqkkdrpe [ iy + 1 ] ; sth += rtDW . dlac4no1kf [ iy + 1 ] ; } if ( rtDW . c0ddl114m0 > 0.0 ) { rtDW . c0ddl114m0 -- ; } else if ( rtB . c3f5my0yba [ 0 ] > cth / 7.0 + 0.005 ) { rtDW . of44i41wjh ++ ; rtDW . c0ddl114m0 = 10.0 ; } if ( rtDW . bpv12jq0j2 > 0.0 ) { rtDW . bpv12jq0j2 -- ; } else if ( rtB . c3f5my0yba [ 1 ] > sth / 7.0 + 0.005 ) { rtDW . anrkqgyd0y ++ ; rtDW . bpv12jq0j2 = 10.0 ; } rtDW . ppafdi3a1m = orjgypckdn ; if ( muDoubleScalarMax ( rtDW . of44i41wjh , rtDW . anrkqgyd0y ) == 0.0 ) { ltaoftfzmt_p = 0.0 ; } else if ( muDoubleScalarAbs ( rtDW . of44i41wjh - rtDW . anrkqgyd0y ) < 0.5 * muDoubleScalarMax ( rtDW . of44i41wjh , rtDW . anrkqgyd0y ) ) { ltaoftfzmt_p = ( rtDW . of44i41wjh + rtDW . anrkqgyd0y ) / 2.0 ; } else { ltaoftfzmt_p = muDoubleScalarMax ( rtDW . of44i41wjh , rtDW . anrkqgyd0y ) ; } rtB . gtf5bhspr5 = rtP . errormargin_Gain * ltaoftfzmt_p * rtP . distanceconverter_Gain ; } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { if ( rtDW . cxaqlklp3z < 255U ) { rtDW . cxaqlklp3z ++ ; } rtDW . pinldolpql = orjgypckdn ; if ( rtDW . azfivy5wqv == 0 ) { rtDW . azfivy5wqv = 1U ; rtDW . cxaqlklp3z = 0U ; rtDW . lhfc0ta5ml = az4wgpee0y ; rtB . iaho3wpxg5 = 0.0 ; rtB . fspxye1ya1 = 0.0 ; rtB . kbi5gtax1r = 0.0 ; rtB . nwh2ohbvkv = 0.0 ; rtB . hy1sdasjsw = 1.0 ; rtB . dp50dq5tps = 1.0 ; rtDW . fiug4ptcox = 0.1 ; rtDW . egry1geo3t = false ; rtDW . km1goje2r1 = false ; } else { switch ( rtDW . lhfc0ta5ml ) { case gjpgqj5mdd : if ( rtDW . k5vzkvexn5 == NextState_END ) { rtDW . lhfc0ta5ml = nv1kkqyxbo ; rtB . iaho3wpxg5 = 0.0 ; rtB . fspxye1ya1 = 0.0 ; rtB . n504o31mpd = true ; } else if ( rtDW . k5vzkvexn5 == NextState_SCAN_ENV ) { rtDW . lhfc0ta5ml = n31l1rb55f ; rtDW . ftjkxzybsy = ( rtB . euqty000s5 > egz3zmqyzt ) ; rtDW . dkcwlolqxl = ( rtB . o4oyjbghkn > egz3zmqyzt ) ; rtDW . hrd2dtqf1n = ( rtB . aw5fvfkl4k > egz3zmqyzt ) ; } break ; case f1wxpecy54 : if ( rtDW . k5vzkvexn5 == NextState_MOVE_FORWARD ) { rtDW . lhfc0ta5ml = hitpnsghgy ; rtDW . gcoa440zpp = rtB . gtf5bhspr5 ; rtDW . gz5an5grm2 = rtDW . ftjkxzybsy ; rtDW . keotauvojf = rtDW . hrd2dtqf1n ; rtDW . glguabnpzh = false ; rtB . iaho3wpxg5 = az4xivd4ux ; rtB . fspxye1ya1 = az4xivd4ux ; } else if ( rtDW . k5vzkvexn5 == NextState_TURN_RIGHT ) { rtDW . lhfc0ta5ml = juuihyq1nj ; rtDW . ei11pgnka4 = rtB . jnbt4dp1zd ; rtDW . hryhffuttt = 1.5707963267948966 ; rtB . iaho3wpxg5 = fad4po45m1 ; rtB . fspxye1ya1 = - 60.0 ; } else if ( rtDW . k5vzkvexn5 == NextState_TURN_BACK ) { rtDW . lhfc0ta5ml = hdurwvxf2i ; rtDW . ei11pgnka4 = rtB . jnbt4dp1zd ; rtDW . hryhffuttt = 3.1415926535897931 ; rtB . iaho3wpxg5 = - 60.0 ; rtB . fspxye1ya1 = fad4po45m1 ; } else if ( rtDW . k5vzkvexn5 == NextState_TURN_LEFT ) { rtDW . lhfc0ta5ml = mvdsbzjsqh ; rtDW . ei11pgnka4 = rtB . jnbt4dp1zd ; rtDW . hryhffuttt = 1.5707963267948966 ; rtB . iaho3wpxg5 = - 60.0 ; rtB . fspxye1ya1 = fad4po45m1 ; } break ; case nv1kkqyxbo : rtB . iaho3wpxg5 = 0.0 ; rtB . fspxye1ya1 = 0.0 ; rtB . n504o31mpd = true ; break ; case az4wgpee0y : if ( rtDW . cxaqlklp3z >= 200 ) { rtDW . lhfc0ta5ml = n31l1rb55f ; rtDW . ftjkxzybsy = ( rtB . euqty000s5 > egz3zmqyzt ) ; rtDW . dkcwlolqxl = ( rtB . o4oyjbghkn > egz3zmqyzt ) ; rtDW . hrd2dtqf1n = ( rtB . aw5fvfkl4k > egz3zmqyzt ) ; } break ; case hitpnsghgy : gsrcmjw0ug ( ) ; break ; case n31l1rb55f : rtDW . lhfc0ta5ml = f1wxpecy54 ; if ( rtDW . ftjkxzybsy ) { rtDW . k5vzkvexn5 = NextState_TURN_LEFT ; } else if ( rtDW . dkcwlolqxl ) { rtDW . k5vzkvexn5 = NextState_MOVE_FORWARD ; } else if ( rtDW . hrd2dtqf1n ) { rtDW . k5vzkvexn5 = NextState_TURN_RIGHT ; } else { rtDW . k5vzkvexn5 = NextState_TURN_BACK ; } break ; case hdurwvxf2i : if ( rtDW . k5vzkvexn5 == NextState_MOVE_FORWARD ) { rtDW . lhfc0ta5ml = hitpnsghgy ; rtDW . gcoa440zpp = rtB . gtf5bhspr5 ; rtDW . gz5an5grm2 = rtDW . ftjkxzybsy ; rtDW . keotauvojf = rtDW . hrd2dtqf1n ; rtDW . glguabnpzh = false ; rtB . iaho3wpxg5 = az4xivd4ux ; rtB . fspxye1ya1 = az4xivd4ux ; } else { rtDW . pkjabwswri = rtB . jnbt4dp1zd - rtDW . ei11pgnka4 ; if ( muDoubleScalarAbs ( rtDW . pkjabwswri ) >= rtDW . hryhffuttt ) { if ( muDoubleScalarIsNaN ( rtB . hy1sdasjsw + 2.0 ) || muDoubleScalarIsInf ( rtB . hy1sdasjsw + 2.0 ) ) { rtB . hy1sdasjsw = ( rtNaN ) ; } else { rtB . hy1sdasjsw = muDoubleScalarRem ( rtB . hy1sdasjsw + 2.0 , 4.0 ) ; if ( rtB . hy1sdasjsw == 0.0 ) { rtB . hy1sdasjsw = 0.0 ; } else if ( rtB . hy1sdasjsw < 0.0 ) { rtB . hy1sdasjsw += 4.0 ; } } rtB . iaho3wpxg5 = 0.0 ; rtB . fspxye1ya1 = 0.0 ; rtDW . km1goje2r1 = true ; rtDW . k5vzkvexn5 = NextState_MOVE_FORWARD ; } } break ; case mvdsbzjsqh : if ( rtDW . k5vzkvexn5 == NextState_MOVE_FORWARD ) { rtDW . lhfc0ta5ml = hitpnsghgy ; rtDW . gcoa440zpp = rtB . gtf5bhspr5 ; rtDW . gz5an5grm2 = rtDW . ftjkxzybsy ; rtDW . keotauvojf = rtDW . hrd2dtqf1n ; rtDW . glguabnpzh = false ; rtB . iaho3wpxg5 = az4xivd4ux ; rtB . fspxye1ya1 = az4xivd4ux ; } else { rtDW . pkjabwswri = rtB . jnbt4dp1zd - rtDW . ei11pgnka4 ; cgoxoes3ro ( & rtDW . pkjabwswri ) ; if ( muDoubleScalarAbs ( rtDW . pkjabwswri ) >= rtDW . hryhffuttt ) { if ( muDoubleScalarIsNaN ( rtB . hy1sdasjsw + 3.0 ) || muDoubleScalarIsInf ( rtB . hy1sdasjsw + 3.0 ) ) { rtB . hy1sdasjsw = ( rtNaN ) ; } else { rtB . hy1sdasjsw = muDoubleScalarRem ( rtB . hy1sdasjsw + 3.0 , 4.0 ) ; if ( rtB . hy1sdasjsw == 0.0 ) { rtB . hy1sdasjsw = 0.0 ; } else if ( rtB . hy1sdasjsw < 0.0 ) { rtB . hy1sdasjsw += 4.0 ; } } rtB . iaho3wpxg5 = 0.0 ; rtB . fspxye1ya1 = 0.0 ; rtDW . km1goje2r1 = true ; rtDW . k5vzkvexn5 = NextState_MOVE_FORWARD ; } } break ; case juuihyq1nj : if ( rtDW . k5vzkvexn5 == NextState_MOVE_FORWARD ) { rtDW . lhfc0ta5ml = hitpnsghgy ; rtDW . gcoa440zpp = rtB . gtf5bhspr5 ; rtDW . gz5an5grm2 = rtDW . ftjkxzybsy ; rtDW . keotauvojf = rtDW . hrd2dtqf1n ; rtDW . glguabnpzh = false ; rtB . iaho3wpxg5 = az4xivd4ux ; rtB . fspxye1ya1 = az4xivd4ux ; } else { rtDW . pkjabwswri = rtDW . ei11pgnka4 - rtB . jnbt4dp1zd ; cgoxoes3ro ( & rtDW . pkjabwswri ) ; if ( muDoubleScalarAbs ( rtDW . pkjabwswri ) >= rtDW . hryhffuttt ) { if ( muDoubleScalarIsNaN ( rtB . hy1sdasjsw + 1.0 ) || muDoubleScalarIsInf ( rtB . hy1sdasjsw + 1.0 ) ) { rtB . hy1sdasjsw = ( rtNaN ) ; } else { rtB . hy1sdasjsw = muDoubleScalarRem ( rtB . hy1sdasjsw + 1.0 , 4.0 ) ; if ( rtB . hy1sdasjsw == 0.0 ) { rtB . hy1sdasjsw = 0.0 ; } else if ( rtB . hy1sdasjsw < 0.0 ) { rtB . hy1sdasjsw += 4.0 ; } } rtB . iaho3wpxg5 = 0.0 ; rtB . fspxye1ya1 = 0.0 ; rtDW . km1goje2r1 = true ; rtDW . k5vzkvexn5 = NextState_MOVE_FORWARD ; } } break ; default : if ( rtDW . k5vzkvexn5 == NextState_CHECK_DONE ) { rtDW . lhfc0ta5ml = gjpgqj5mdd ; if ( rtB . dp50dq5tps >= p05b0zukjc ) { rtDW . egry1geo3t = true ; rtDW . k5vzkvexn5 = NextState_END ; } else { rtDW . k5vzkvexn5 = NextState_SCAN_ENV ; } } break ; } } } rtDW . p1x2oxibuy = orjgypckdn ; rtB . ohbrmglluj = 0.0 ; sth = rtB . h4kspc310t * rtP . simstruct . mapres + 1.0 ; cth = muDoubleScalarRound ( rtB . gvkjqyfh5c * rtP . simstruct . mapres ) ; if ( ( cth + 1.0 < 1.0 ) || ( cth + 1.0 > 400.0 ) || ( sth < 1.0 ) || ( sth > 601.0 ) ) { rtB . ohbrmglluj = 1.0 ; } else if ( rtP . simstruct . mapdt [ ( ( ( int32_T ) sth - 1 ) * 400 + ( int32_T ) ( cth + 1.0 ) ) - 1 ] < rtP . simstruct . robot_rad ) { rtB . ohbrmglluj = 1.0 ; } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { if ( rtB . ohbrmglluj != 0.0 ) { ssSetStopRequested ( rtS , 1 ) ; } rtAction = - 1 ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { if ( rtB . n504o31mpd ) { rtAction = 0 ; } rtDW . cshvnu2qj4 = rtAction ; } else { rtAction = rtDW . cshvnu2qj4 ; } if ( rtAction == 0 ) { rtB . kzc2g5pqze = rtP . Constant_Value_e2dunptcm0 ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { srUpdateBC ( rtDW . anun1akbzt ) ; } } if ( rtB . kzc2g5pqze != 0.0 ) { ssSetStopRequested ( rtS , 1 ) ; } rtB . ggd3q5xetv = rtP . Gain_Gain * rtB . fspxye1ya1 ; rtB . b0avxogppv = rtP . Gain1_Gain * rtB . iaho3wpxg5 ; dt1kotclqk [ 0 ] = rtB . kwftyjyxpv [ 1 ] ; dt1kotclqk [ 1 ] = 0.0 ; dt1kotclqk [ 2 ] = 0.0 ; dt1kotclqk [ 3 ] = 0.0 ; { if ( rtDW . ptoetb01hb . AQHandles && ssGetLogOutput ( rtS ) ) { sdiWriteSignal ( rtDW . ptoetb01hb . AQHandles , ssGetTaskTime ( rtS , 1 ) , ( char * ) & dt1kotclqk [ 0 ] + 0 ) ; } } dt1kotclqk [ 0 ] = rtB . kwftyjyxpv [ 0 ] ; dt1kotclqk [ 1 ] = 0.0 ; dt1kotclqk [ 2 ] = 0.0 ; dt1kotclqk [ 3 ] = 0.0 ; { if ( rtDW . fcrqtiosyn . AQHandles && ssGetLogOutput ( rtS ) ) { sdiWriteSignal ( rtDW . fcrqtiosyn . AQHandles , ssGetTaskTime ( rtS , 1 ) , ( char * ) & dt1kotclqk [ 0 ] + 0 ) ; } } dt1kotclqk [ 0 ] = rtB . kwftyjyxpv [ 2 ] ; dt1kotclqk [ 1 ] = 0.0 ; dt1kotclqk [ 2 ] = 0.0 ; dt1kotclqk [ 3 ] = 0.0 ; { if ( rtDW . brzhetjznx . AQHandles && ssGetLogOutput ( rtS ) ) { sdiWriteSignal ( rtDW . brzhetjznx . AQHandles , ssGetTaskTime ( rtS , 1 ) , ( char * ) & dt1kotclqk [ 0 ] + 0 ) ; } } cth = muDoubleScalarMax ( rtB . bm3zqotgwb [ 0 ] , rtP . LowPassFilterDiscreteorContinuous3_T ) ; rtB . nwdsz2ijro = ( real_T ) ( cth == 0.0 ) * 2.2204460492503131e-16 + cth ; cth = muDoubleScalarMax ( rtB . gc0h2fcjlf [ 0 ] , rtP . LowPassFilterDiscreteorContinuous4_T ) ; rtB . mja435uye4 = ( real_T ) ( cth == 0.0 ) * 2.2204460492503131e-16 + cth ; cth = muDoubleScalarMax ( rtB . d5bexgg5ud [ 0 ] , rtP . LowPassFilterDiscreteorContinuous5_T ) ; rtB . o1u44cgbcz = ( real_T ) ( cth == 0.0 ) * 2.2204460492503131e-16 + cth ; } rtB . avr1raogew = 1.0 / rtB . nwdsz2ijro * ( rtB . ewf4owjito - rtB . euqty000s5 ) ; rtB . jph2p0erwe = 1.0 / rtB . mja435uye4 * ( rtB . ivhyg3ka2t - rtB . o4oyjbghkn ) ; rtB . mmvr34tq4s = 1.0 / rtB . o1u44cgbcz * ( rtB . geack2hgej - rtB . aw5fvfkl4k ) ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . nls3sblsfo = orjgypckdn ; if ( rtDW . bymhg25233 == 0 ) { rtDW . bymhg25233 = 1U ; rtDW . chcmzyq1nu = c1maqusr1t ; } rtDW . hivxqwy2wg = orjgypckdn ; if ( ! rtDW . cpqsdojs4v ) { rtDW . hthc5b4czm = 1.0 ; rtDW . cpqsdojs4v = true ; rtDW . lsryszinou = 1.0 ; rtDW . g3h3iifz4a = true ; memset ( & rtDW . jbbzdspg0o [ 0 ] , 0 , 24U * sizeof ( real_T ) ) ; rtDW . auf11wecna = true ; rtDW . jbbzdspg0o [ 0 ] = 1.0 ; rtDW . j3fo2xlqpp = 0.0 ; rtDW . eottp2wq2b = true ; rtDW . hv3cm0cioe = true ; rtDW . nk0ebvht3j = 0.1 ; rtDW . jtr2pdj40h = true ; rtDW . oavskvfao1 = 0.1 ; rtDW . az214v0nqt = true ; } rtDW . oa1ipehqlk = 0.0 ; rtDW . nk0ebvht3j += rtDW . j3fo2xlqpp ; rtDW . oavskvfao1 += rtDW . j3fo2xlqpp * 0.0 ; rtDW . j3fo2xlqpp = 0.0 ; cth = muDoubleScalarFloor ( rtDW . nk0ebvht3j / 0.2 ) ; sth = muDoubleScalarFloor ( rtDW . oavskvfao1 / 0.2 ) ; if ( cth != 0.0 ) { rtDW . lsryszinou = muDoubleScalarMin ( muDoubleScalarMax ( muDoubleScalarSign ( rtDW . nk0ebvht3j ) * muDoubleScalarAbs ( cth ) + rtDW . lsryszinou , 1.0 ) , 6.0 ) ; } if ( sth != 0.0 ) { rtDW . hthc5b4czm = muDoubleScalarMin ( muDoubleScalarMax ( muDoubleScalarSign ( rtDW . oavskvfao1 ) * muDoubleScalarAbs ( sth ) + rtDW . hthc5b4czm , 1.0 ) , 4.0 ) ; } rtDW . jbbzdspg0o [ ( ( int32_T ) rtDW . hthc5b4czm + ( ( ( int32_T ) rtDW . lsryszinou - 1 ) << 2 ) ) - 1 ] = 1.0 ; rtDW . nk0ebvht3j -= cth * 0.2 ; rtDW . oavskvfao1 -= sth * 0.2 ; rtDW . ag2o5lx0zx = orjgypckdn ; if ( rtDW . fffjpdz1bc ) { if ( rtDW . ibjaxusqtb == 1.0 ) { if ( ! ( rtDW . bhzxd4c0jb > 0.0 ) ) { rtDW . fffjpdz1bc = false ; } } else if ( ( rtDW . ibjaxusqtb == - 1.0 ) && ( ! ( rtDW . bhzxd4c0jb < 0.0 ) ) ) { rtDW . fffjpdz1bc = false ; } } v [ 0 ] = rtB . h4kspc310t ; v [ 1 ] = rtB . gvkjqyfh5c ; v [ 2 ] = rtB . cngfn1wxw4 ; { if ( rtDW . bxw3wejwzq . AQHandles && ssGetLogOutput ( rtS ) ) { sdiWriteSignal ( rtDW . bxw3wejwzq . AQHandles , ssGetTaskTime ( rtS , 1 ) , ( char * ) & v [ 0 ] + 0 ) ; } } } rtDW . kjbt4d23ke = orjgypckdn ; ls4od3kfux ( & simstruct , 3 ) ; aub0azqxc3 ( rtP . simstruct . robot_img , - rtB . cngfn1wxw4 * 180.0 / 3.1415926535897931 , simstruct ) ; pbx1k3tjdc ( & simstruct ) ; cth = - rtB . cngfn1wxw4 * 180.0 / 3.1415926535897931 ; if ( ! ( muDoubleScalarRem ( cth , 90.0 ) == 0.0 ) ) { sth = cth ; ianmg0smpl ( & sth ) ; frni2y1egs ( & cth ) ; bd1u2nprke [ 0 ] = cth ; bd1u2nprke [ 3 ] = - sth ; bd1u2nprke [ 6 ] = 0.0 ; bd1u2nprke [ 1 ] = sth ; bd1u2nprke [ 4 ] = cth ; bd1u2nprke [ 7 ] = 0.0 ; bd1u2nprke [ 2 ] = 0.0 ; bd1u2nprke [ 5 ] = 0.0 ; bd1u2nprke [ 8 ] = 1.0 ; memcpy ( & catArgs [ 0 ] , & bd1u2nprke [ 0 ] , 9U * sizeof ( real_T ) ) ; hykqgtpupg ( catArgs , ipiv , & iy ) ; for ( iy = 0 ; iy < 9 ; iy ++ ) { tempR [ iy ] = bd1u2nprke [ iy ] ; h1q3iyvvtx = c_p [ iy ] ; ltaoftfzmt_p = d [ iy ] ; catArgs [ iy ] = cth * h1q3iyvvtx + sth * ltaoftfzmt_p ; bd1u2nprke [ iy ] = - sth * h1q3iyvvtx + cth * ltaoftfzmt_p ; } dt1kotclqk [ 0 ] = oqrcmmpxbs ( catArgs ) ; dt1kotclqk [ 2 ] = flf2eicnum ( catArgs ) ; dt1kotclqk [ 1 ] = oqrcmmpxbs ( bd1u2nprke ) ; dt1kotclqk [ 3 ] = flf2eicnum ( bd1u2nprke ) ; sth = ( muDoubleScalarCeil ( dt1kotclqk [ 2 ] - dt1kotclqk [ 0 ] ) - ( dt1kotclqk [ 2 ] - dt1kotclqk [ 0 ] ) ) / 2.0 ; cth = ( muDoubleScalarCeil ( dt1kotclqk [ 3 ] - dt1kotclqk [ 1 ] ) - ( dt1kotclqk [ 3 ] - dt1kotclqk [ 1 ] ) ) / 2.0 ; ebm4h2e2p2 [ 0 ] = dt1kotclqk [ 0 ] - sth ; ebm4h2e2p2 [ 1 ] = dt1kotclqk [ 2 ] + sth ; nfqanpjdrg ( & Rout , ebm4h2e2p2 ) ; ebm4h2e2p2 [ 0 ] = dt1kotclqk [ 1 ] - cth ; ebm4h2e2p2 [ 1 ] = dt1kotclqk [ 3 ] + cth ; g2dnl35ryz ( & Rout , ebm4h2e2p2 ) ; cth = ( Rout . XWorldLimits [ 0 ] + Rout . XWorldLimits [ 1 ] ) / 2.0 ; sth = ( Rout . YWorldLimits [ 0 ] + Rout . YWorldLimits [ 1 ] ) / 2.0 ; ebm4h2e2p2 [ 0 ] = ( cth - 101.0 ) + 0.5 ; ebm4h2e2p2 [ 1 ] = ( cth - 101.0 ) + 201.5 ; nfqanpjdrg ( & Rout , ebm4h2e2p2 ) ; ebm4h2e2p2 [ 0 ] = ( sth - 101.0 ) + 0.5 ; ebm4h2e2p2 [ 1 ] = ( sth - 101.0 ) + 201.5 ; g2dnl35ryz ( & Rout , ebm4h2e2p2 ) ; ckudj3qznmi ( rtP . simstruct . robot_imgalpha , tempR , Rout . XWorldLimits , Rout . YWorldLimits , rtB . simstruct . data , rtB . simstruct . size ) ; } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtB . o3awe1dagi = rtP . simstruct . R / 2.0 * ( rtB . ggd3q5xetv + rtB . b0avxogppv ) ; rtB . nbug4ir3tw = rtP . simstruct . R / ( 2.0 * rtP . simstruct . L ) * ( rtB . ggd3q5xetv - rtB . b0avxogppv ) ; } rtB . aq0w45afqv = muDoubleScalarSin ( rtB . cngfn1wxw4 ) * rtB . o3awe1dagi ; rtB . ks2rov0eom = muDoubleScalarCos ( rtB . cngfn1wxw4 ) * rtB . o3awe1dagi ; UNUSED_PARAMETER ( tid ) ; } void MdlOutputsTID3 ( int_T tid ) { rtB . cngravbh2r = ( rtP . LowPassFilterDiscreteorContinuous3_init_option < rtP . CompareToConstant_const ) ; rtB . caujwou1jk = ( rtP . LowPassFilterDiscreteorContinuous4_init_option < rtP . CompareToConstant_const_izdv1scwad ) ; rtB . ntxg1addth = ( rtP . LowPassFilterDiscreteorContinuous5_init_option < rtP . CompareToConstant_const_a4stry1zs4 ) ; UNUSED_PARAMETER ( tid ) ; } void MdlUpdate ( int_T tid ) { real_T * lastU ; if ( rtDW . i5bvacsh1c == ( rtInf ) ) { rtDW . i5bvacsh1c = ssGetT ( rtS ) ; lastU = & rtDW . j0pj1cxjdn ; } else if ( rtDW . hj4s3vhbsm == ( rtInf ) ) { rtDW . hj4s3vhbsm = ssGetT ( rtS ) ; lastU = & rtDW . n3g3ymlzmr ; } else if ( rtDW . i5bvacsh1c < rtDW . hj4s3vhbsm ) { rtDW . i5bvacsh1c = ssGetT ( rtS ) ; lastU = & rtDW . j0pj1cxjdn ; } else { rtDW . hj4s3vhbsm = ssGetT ( rtS ) ; lastU = & rtDW . n3g3ymlzmr ; } * lastU = rtB . h4kspc310t ; if ( rtDW . gqfi4xcbpq == ( rtInf ) ) { rtDW . gqfi4xcbpq = ssGetT ( rtS ) ; lastU = & rtDW . nltseoa5tf ; } else if ( rtDW . jf4thnpuad == ( rtInf ) ) { rtDW . jf4thnpuad = ssGetT ( rtS ) ; lastU = & rtDW . mjsm4xz2fd ; } else if ( rtDW . gqfi4xcbpq < rtDW . jf4thnpuad ) { rtDW . gqfi4xcbpq = ssGetT ( rtS ) ; lastU = & rtDW . nltseoa5tf ; } else { rtDW . jf4thnpuad = ssGetT ( rtS ) ; lastU = & rtDW . mjsm4xz2fd ; } * lastU = rtB . i1ks4nvn04 ; if ( rtDW . msu0usinuw == ( rtInf ) ) { rtDW . msu0usinuw = ssGetT ( rtS ) ; lastU = & rtDW . eb5ua2po2y ; } else if ( rtDW . a4phy4pqvq == ( rtInf ) ) { rtDW . a4phy4pqvq = ssGetT ( rtS ) ; lastU = & rtDW . ht4sfrmguj ; } else if ( rtDW . msu0usinuw < rtDW . a4phy4pqvq ) { rtDW . msu0usinuw = ssGetT ( rtS ) ; lastU = & rtDW . eb5ua2po2y ; } else { rtDW . a4phy4pqvq = ssGetT ( rtS ) ; lastU = & rtDW . ht4sfrmguj ; } * lastU = rtB . gvkjqyfh5c ; if ( rtDW . fvuqlob3jg == ( rtInf ) ) { rtDW . fvuqlob3jg = ssGetT ( rtS ) ; lastU = & rtDW . ghpi3etgoe ; } else if ( rtDW . b5ciq54a2a == ( rtInf ) ) { rtDW . b5ciq54a2a = ssGetT ( rtS ) ; lastU = & rtDW . as3jc4aixp ; } else if ( rtDW . fvuqlob3jg < rtDW . b5ciq54a2a ) { rtDW . fvuqlob3jg = ssGetT ( rtS ) ; lastU = & rtDW . ghpi3etgoe ; } else { rtDW . b5ciq54a2a = ssGetT ( rtS ) ; lastU = & rtDW . as3jc4aixp ; } * lastU = rtB . kxrvfu1ehv ; if ( rtDW . kw4mcnvapg == ( rtInf ) ) { rtDW . kw4mcnvapg = ssGetT ( rtS ) ; lastU = & rtDW . hekbx12zjf ; } else if ( rtDW . dg4bndzwcf == ( rtInf ) ) { rtDW . dg4bndzwcf = ssGetT ( rtS ) ; lastU = & rtDW . bsz2i3x1zz ; } else if ( rtDW . kw4mcnvapg < rtDW . dg4bndzwcf ) { rtDW . kw4mcnvapg = ssGetT ( rtS ) ; lastU = & rtDW . hekbx12zjf ; } else { rtDW . dg4bndzwcf = ssGetT ( rtS ) ; lastU = & rtDW . bsz2i3x1zz ; } * lastU = rtB . cngfn1wxw4 ; if ( rtDW . guxmnl3023 == ( rtInf ) ) { rtDW . guxmnl3023 = ssGetT ( rtS ) ; lastU = & rtDW . mkaulxhvv5 ; } else if ( rtDW . k4bunfh2cu == ( rtInf ) ) { rtDW . k4bunfh2cu = ssGetT ( rtS ) ; lastU = & rtDW . omd2l4th2w ; } else if ( rtDW . guxmnl3023 < rtDW . k4bunfh2cu ) { rtDW . guxmnl3023 = ssGetT ( rtS ) ; lastU = & rtDW . mkaulxhvv5 ; } else { rtDW . k4bunfh2cu = ssGetT ( rtS ) ; lastU = & rtDW . omd2l4th2w ; } * lastU = rtB . lsr13h5kid ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . k00pa3laqh = 0U ; rtDW . e2tyz0qrrq += rtP . Integrator_gainval * rtB . avr1raogew ; if ( rtDW . e2tyz0qrrq > rtP . Integrator_UpperSat ) { rtDW . e2tyz0qrrq = rtP . Integrator_UpperSat ; } else if ( rtDW . e2tyz0qrrq < rtP . Integrator_LowerSat ) { rtDW . e2tyz0qrrq = rtP . Integrator_LowerSat ; } rtDW . hgyf2n5vgw = ( int8_T ) rtB . dv5fmxftb2 ; rtDW . omatkykwmc = 0U ; rtDW . dupakdsnzz += rtP . Integrator_gainval_pmkfkwu0cc * rtB . jph2p0erwe ; if ( rtDW . dupakdsnzz > rtP . Integrator_UpperSat_kzv3sf2wkn ) { rtDW . dupakdsnzz = rtP . Integrator_UpperSat_kzv3sf2wkn ; } else if ( rtDW . dupakdsnzz < rtP . Integrator_LowerSat_et0vhzjblr ) { rtDW . dupakdsnzz = rtP . Integrator_LowerSat_et0vhzjblr ; } rtDW . n0ab4hkwjr = ( int8_T ) rtB . hez31ivcnc ; rtDW . h2aulvebrm = 0U ; rtDW . a5hvpj25th += rtP . Integrator_gainval_oyqv0ladld * rtB . mmvr34tq4s ; if ( rtDW . a5hvpj25th > rtP . Integrator_UpperSat_fgmadlykzp ) { rtDW . a5hvpj25th = rtP . Integrator_UpperSat_fgmadlykzp ; } else if ( rtDW . a5hvpj25th < rtP . Integrator_LowerSat_kbaak3f5xe ) { rtDW . a5hvpj25th = rtP . Integrator_LowerSat_kbaak3f5xe ; } rtDW . p34vnxg4cl = ( int8_T ) rtB . pbnizhjvzo ; } UNUSED_PARAMETER ( tid ) ; } void MdlUpdateTID3 ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlDerivatives ( void ) { XDot * _rtXdot ; _rtXdot = ( ( XDot * ) ssGetdX ( rtS ) ) ; _rtXdot -> o3znemhc2a = rtB . nbug4ir3tw ; _rtXdot -> b3xdnyzu1i = rtB . ks2rov0eom ; _rtXdot -> o3b0zoxyg1 = rtB . aq0w45afqv ; _rtXdot -> decrl0oxjd = rtB . ehm3yytxoa [ 2 ] ; _rtXdot -> brvdk5f5hy = rtB . b0avxogppv ; _rtXdot -> b414ta1ujl = rtB . ggd3q5xetv ; _rtXdot -> gjp2vw2s4j = 0.0 ; } void MdlProjection ( void ) { } void MdlTerminate ( void ) { { if ( rtDW . ptoetb01hb . AQHandles ) { sdiTerminateStreaming ( & rtDW . ptoetb01hb . AQHandles ) ; } } { if ( rtDW . fcrqtiosyn . AQHandles ) { sdiTerminateStreaming ( & rtDW . fcrqtiosyn . AQHandles ) ; } } { if ( rtDW . brzhetjznx . AQHandles ) { sdiTerminateStreaming ( & rtDW . brzhetjznx . AQHandles ) ; } } { if ( rtDW . bxw3wejwzq . AQHandles ) { sdiTerminateStreaming ( & rtDW . bxw3wejwzq . AQHandles ) ; } } } static void mr_mm_autograde_M2_nice_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) ; static void mr_mm_autograde_M2_nice_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) { mxArray * newArray = mxCreateUninitNumericMatrix ( ( size_t ) 1 , numBytes , mxUINT8_CLASS , mxREAL ) ; memcpy ( ( uint8_T * ) mxGetData ( newArray ) , ( const uint8_T * ) srcData , numBytes ) ; mxSetFieldByNumber ( destArray , i , j , newArray ) ; } static void mr_mm_autograde_M2_nice_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) ; static void mr_mm_autograde_M2_nice_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) { memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) , numBytes ) ; } static void mr_mm_autograde_M2_nice_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) ; static void mr_mm_autograde_M2_nice_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) { mxSetFieldByNumber ( destArray , i , j , mxCreateDoubleScalar ( ( real_T ) bitVal ) ) ; } static uint_T mr_mm_autograde_M2_nice_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) ; static uint_T mr_mm_autograde_M2_nice_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) { const uint_T varVal = ( uint_T ) mxGetScalar ( mxGetFieldByNumber ( srcArray , i , j ) ) ; return varVal & ( ( 1u << numBits ) - 1u ) ; } static void mr_mm_autograde_M2_nice_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) ; static void mr_mm_autograde_M2_nice_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) { uint8_T * varData = ( uint8_T * ) mxGetData ( mxGetFieldByNumber ( destArray , i , j ) ) ; memcpy ( ( uint8_T * ) & varData [ offset * numBytes ] , ( const uint8_T * ) srcData , numBytes ) ; } static void mr_mm_autograde_M2_nice_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) ; static void mr_mm_autograde_M2_nice_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) { const uint8_T * varData = ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) ; memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) & varData [ offset * numBytes ] , numBytes ) ; } static void mr_mm_autograde_M2_nice_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) ; static void mr_mm_autograde_M2_nice_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) { mxSetCell ( mxGetFieldByNumber ( destArray , i , j ) , offset , mxCreateDoubleScalar ( ( real_T ) fieldVal ) ) ; } static uint_T mr_mm_autograde_M2_nice_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) ; static uint_T mr_mm_autograde_M2_nice_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) { const uint_T fieldVal = ( uint_T ) mxGetScalar ( mxGetCell ( mxGetFieldByNumber ( srcArray , i , j ) , offset ) ) ; return fieldVal & ( ( 1u << numBits ) - 1u ) ; } mxArray * mr_mm_autograde_M2_nice_GetDWork ( ) { static const char_T * ssDWFieldNames [ 3 ] = { "rtB" , "rtDW" , "NULL_PrevZCX" , } ; mxArray * ssDW = mxCreateStructMatrix ( 1 , 1 , 3 , ssDWFieldNames ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( ssDW , 0 , 0 , ( const void * ) & ( rtB ) , sizeof ( rtB ) ) ; { static const char_T * rtdwDataFieldNames [ 113 ] = { "rtDW.e2tyz0qrrq" , "rtDW.dupakdsnzz" , "rtDW.a5hvpj25th" , "rtDW.i5bvacsh1c" , "rtDW.j0pj1cxjdn" , "rtDW.hj4s3vhbsm" , "rtDW.n3g3ymlzmr" , "rtDW.gqfi4xcbpq" , "rtDW.nltseoa5tf" , "rtDW.jf4thnpuad" , "rtDW.mjsm4xz2fd" , "rtDW.msu0usinuw" , "rtDW.eb5ua2po2y" , "rtDW.a4phy4pqvq" , "rtDW.ht4sfrmguj" , "rtDW.fvuqlob3jg" , "rtDW.ghpi3etgoe" , "rtDW.b5ciq54a2a" , "rtDW.as3jc4aixp" , "rtDW.kw4mcnvapg" , "rtDW.hekbx12zjf" , "rtDW.dg4bndzwcf" , "rtDW.bsz2i3x1zz" , "rtDW.guxmnl3023" , "rtDW.mkaulxhvv5" , "rtDW.k4bunfh2cu" , "rtDW.omd2l4th2w" , "rtDW.ibjaxusqtb" , "rtDW.bhzxd4c0jb" , "rtDW.gcoa440zpp" , "rtDW.fiug4ptcox" , "rtDW.ei11pgnka4" , "rtDW.hryhffuttt" , "rtDW.pkjabwswri" , "rtDW.hvlgcytolm" , "rtDW.ahadgjvl0w" , "rtDW.hthc5b4czm" , "rtDW.lsryszinou" , "rtDW.jbbzdspg0o" , "rtDW.j3fo2xlqpp" , "rtDW.oa1ipehqlk" , "rtDW.nk0ebvht3j" , "rtDW.oavskvfao1" , "rtDW.m5xqkkdrpe" , "rtDW.dlac4no1kf" , "rtDW.kmgfkm3qi1" , "rtDW.of44i41wjh" , "rtDW.anrkqgyd0y" , "rtDW.c0ddl114m0" , "rtDW.bpv12jq0j2" , "rtDW.jcrrh2phtm" , "rtDW.kjbt4d23ke" , "rtDW.jbz5db4uv3" , "rtDW.p1x2oxibuy" , "rtDW.boqo1kfngr" , "rtDW.nmo21jm233" , "rtDW.ppafdi3a1m" , "rtDW.ag2o5lx0zx" , "rtDW.pinldolpql" , "rtDW.hivxqwy2wg" , "rtDW.p1z00yunkl" , "rtDW.nls3sblsfo" , "rtDW.lhfc0ta5ml" , "rtDW.chcmzyq1nu" , "rtDW.k5vzkvexn5" , "rtDW.hgyf2n5vgw" , "rtDW.n0ab4hkwjr" , "rtDW.p34vnxg4cl" , "rtDW.cshvnu2qj4" , "rtDW.anun1akbzt" , "rtDW.k00pa3laqh" , "rtDW.omatkykwmc" , "rtDW.h2aulvebrm" , "rtDW.azfivy5wqv" , "rtDW.cxaqlklp3z" , "rtDW.bymhg25233" , "rtDW.bt4dt4cuu2" , "rtDW.hssax2olko" , "rtDW.cfai5v52fq" , "rtDW.n3w0gkdjc5" , "rtDW.kpwsg1fwo4" , "rtDW.htlid55lmh" , "rtDW.hrnpqly234" , "rtDW.fffjpdz1bc" , "rtDW.ctlazpcn1r" , "rtDW.gpt4l3gxl0" , "rtDW.bwmvjcjrxc" , "rtDW.ftjkxzybsy" , "rtDW.hrd2dtqf1n" , "rtDW.dkcwlolqxl" , "rtDW.egry1geo3t" , "rtDW.gz5an5grm2" , "rtDW.keotauvojf" , "rtDW.glguabnpzh" , "rtDW.km1goje2r1" , "rtDW.mnez3r4wih" , "rtDW.cpqsdojs4v" , "rtDW.g3h3iifz4a" , "rtDW.auf11wecna" , "rtDW.eottp2wq2b" , "rtDW.hv3cm0cioe" , "rtDW.jtr2pdj40h" , "rtDW.az214v0nqt" , "rtDW.axtegouoxr" , "rtDW.ihr0u5jxyq" , "rtDW.jchleqhuy5" , "rtDW.iu2dpnxnxi" , "rtDW.ddvsbh4eeb" , "rtDW.nmgtdqicex" , "rtDW.hkz1fvip5h" , "rtDW.b41p410v44" , "rtDW.jngltzcitg" , "rtDW.hcizcxtpa5" , } ; mxArray * rtdwData = mxCreateStructMatrix ( 1 , 1 , 113 , rtdwDataFieldNames ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 0 , ( const void * ) & ( rtDW . e2tyz0qrrq ) , sizeof ( rtDW . e2tyz0qrrq ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 1 , ( const void * ) & ( rtDW . dupakdsnzz ) , sizeof ( rtDW . dupakdsnzz ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 2 , ( const void * ) & ( rtDW . a5hvpj25th ) , sizeof ( rtDW . a5hvpj25th ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 3 , ( const void * ) & ( rtDW . i5bvacsh1c ) , sizeof ( rtDW . i5bvacsh1c ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 4 , ( const void * ) & ( rtDW . j0pj1cxjdn ) , sizeof ( rtDW . j0pj1cxjdn ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 5 , ( const void * ) & ( rtDW . hj4s3vhbsm ) , sizeof ( rtDW . hj4s3vhbsm ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 6 , ( const void * ) & ( rtDW . n3g3ymlzmr ) , sizeof ( rtDW . n3g3ymlzmr ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 7 , ( const void * ) & ( rtDW . gqfi4xcbpq ) , sizeof ( rtDW . gqfi4xcbpq ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 8 , ( const void * ) & ( rtDW . nltseoa5tf ) , sizeof ( rtDW . nltseoa5tf ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 9 , ( const void * ) & ( rtDW . jf4thnpuad ) , sizeof ( rtDW . jf4thnpuad ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 10 , ( const void * ) & ( rtDW . mjsm4xz2fd ) , sizeof ( rtDW . mjsm4xz2fd ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 11 , ( const void * ) & ( rtDW . msu0usinuw ) , sizeof ( rtDW . msu0usinuw ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 12 , ( const void * ) & ( rtDW . eb5ua2po2y ) , sizeof ( rtDW . eb5ua2po2y ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 13 , ( const void * ) & ( rtDW . a4phy4pqvq ) , sizeof ( rtDW . a4phy4pqvq ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 14 , ( const void * ) & ( rtDW . ht4sfrmguj ) , sizeof ( rtDW . ht4sfrmguj ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 15 , ( const void * ) & ( rtDW . fvuqlob3jg ) , sizeof ( rtDW . fvuqlob3jg ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 16 , ( const void * ) & ( rtDW . ghpi3etgoe ) , sizeof ( rtDW . ghpi3etgoe ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 17 , ( const void * ) & ( rtDW . b5ciq54a2a ) , sizeof ( rtDW . b5ciq54a2a ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 18 , ( const void * ) & ( rtDW . as3jc4aixp ) , sizeof ( rtDW . as3jc4aixp ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 19 , ( const void * ) & ( rtDW . kw4mcnvapg ) , sizeof ( rtDW . kw4mcnvapg ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 20 , ( const void * ) & ( rtDW . hekbx12zjf ) , sizeof ( rtDW . hekbx12zjf ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 21 , ( const void * ) & ( rtDW . dg4bndzwcf ) , sizeof ( rtDW . dg4bndzwcf ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 22 , ( const void * ) & ( rtDW . bsz2i3x1zz ) , sizeof ( rtDW . bsz2i3x1zz ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 23 , ( const void * ) & ( rtDW . guxmnl3023 ) , sizeof ( rtDW . guxmnl3023 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 24 , ( const void * ) & ( rtDW . mkaulxhvv5 ) , sizeof ( rtDW . mkaulxhvv5 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 25 , ( const void * ) & ( rtDW . k4bunfh2cu ) , sizeof ( rtDW . k4bunfh2cu ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 26 , ( const void * ) & ( rtDW . omd2l4th2w ) , sizeof ( rtDW . omd2l4th2w ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 27 , ( const void * ) & ( rtDW . ibjaxusqtb ) , sizeof ( rtDW . ibjaxusqtb ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 28 , ( const void * ) & ( rtDW . bhzxd4c0jb ) , sizeof ( rtDW . bhzxd4c0jb ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 29 , ( const void * ) & ( rtDW . gcoa440zpp ) , sizeof ( rtDW . gcoa440zpp ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 30 , ( const void * ) & ( rtDW . fiug4ptcox ) , sizeof ( rtDW . fiug4ptcox ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 31 , ( const void * ) & ( rtDW . ei11pgnka4 ) , sizeof ( rtDW . ei11pgnka4 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 32 , ( const void * ) & ( rtDW . hryhffuttt ) , sizeof ( rtDW . hryhffuttt ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 33 , ( const void * ) & ( rtDW . pkjabwswri ) , sizeof ( rtDW . pkjabwswri ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 34 , ( const void * ) & ( rtDW . hvlgcytolm ) , sizeof ( rtDW . hvlgcytolm ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 35 , ( const void * ) & ( rtDW . ahadgjvl0w ) , sizeof ( rtDW . ahadgjvl0w ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 36 , ( const void * ) & ( rtDW . hthc5b4czm ) , sizeof ( rtDW . hthc5b4czm ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 37 , ( const void * ) & ( rtDW . lsryszinou ) , sizeof ( rtDW . lsryszinou ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 38 , ( const void * ) & ( rtDW . jbbzdspg0o ) , sizeof ( rtDW . jbbzdspg0o ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 39 , ( const void * ) & ( rtDW . j3fo2xlqpp ) , sizeof ( rtDW . j3fo2xlqpp ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 40 , ( const void * ) & ( rtDW . oa1ipehqlk ) , sizeof ( rtDW . oa1ipehqlk ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 41 , ( const void * ) & ( rtDW . nk0ebvht3j ) , sizeof ( rtDW . nk0ebvht3j ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 42 , ( const void * ) & ( rtDW . oavskvfao1 ) , sizeof ( rtDW . oavskvfao1 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 43 , ( const void * ) & ( rtDW . m5xqkkdrpe ) , sizeof ( rtDW . m5xqkkdrpe ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 44 , ( const void * ) & ( rtDW . dlac4no1kf ) , sizeof ( rtDW . dlac4no1kf ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 45 , ( const void * ) & ( rtDW . kmgfkm3qi1 ) , sizeof ( rtDW . kmgfkm3qi1 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 46 , ( const void * ) & ( rtDW . of44i41wjh ) , sizeof ( rtDW . of44i41wjh ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 47 , ( const void * ) & ( rtDW . anrkqgyd0y ) , sizeof ( rtDW . anrkqgyd0y ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 48 , ( const void * ) & ( rtDW . c0ddl114m0 ) , sizeof ( rtDW . c0ddl114m0 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 49 , ( const void * ) & ( rtDW . bpv12jq0j2 ) , sizeof ( rtDW . bpv12jq0j2 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 50 , ( const void * ) & ( rtDW . jcrrh2phtm ) , sizeof ( rtDW . jcrrh2phtm ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 51 , ( const void * ) & ( rtDW . kjbt4d23ke ) , sizeof ( rtDW . kjbt4d23ke ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 52 , ( const void * ) & ( rtDW . jbz5db4uv3 ) , sizeof ( rtDW . jbz5db4uv3 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 53 , ( const void * ) & ( rtDW . p1x2oxibuy ) , sizeof ( rtDW . p1x2oxibuy ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 54 , ( const void * ) & ( rtDW . boqo1kfngr ) , sizeof ( rtDW . boqo1kfngr ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 55 , ( const void * ) & ( rtDW . nmo21jm233 ) , sizeof ( rtDW . nmo21jm233 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 56 , ( const void * ) & ( rtDW . ppafdi3a1m ) , sizeof ( rtDW . ppafdi3a1m ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 57 , ( const void * ) & ( rtDW . ag2o5lx0zx ) , sizeof ( rtDW . ag2o5lx0zx ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 58 , ( const void * ) & ( rtDW . pinldolpql ) , sizeof ( rtDW . pinldolpql ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 59 , ( const void * ) & ( rtDW . hivxqwy2wg ) , sizeof ( rtDW . hivxqwy2wg ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 60 , ( const void * ) & ( rtDW . p1z00yunkl ) , sizeof ( rtDW . p1z00yunkl ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 61 , ( const void * ) & ( rtDW . nls3sblsfo ) , sizeof ( rtDW . nls3sblsfo ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 62 , ( const void * ) & ( rtDW . lhfc0ta5ml ) , sizeof ( rtDW . lhfc0ta5ml ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 63 , ( const void * ) & ( rtDW . chcmzyq1nu ) , sizeof ( rtDW . chcmzyq1nu ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 64 , ( const void * ) & ( rtDW . k5vzkvexn5 ) , sizeof ( rtDW . k5vzkvexn5 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 65 , ( const void * ) & ( rtDW . hgyf2n5vgw ) , sizeof ( rtDW . hgyf2n5vgw ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 66 , ( const void * ) & ( rtDW . n0ab4hkwjr ) , sizeof ( rtDW . n0ab4hkwjr ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 67 , ( const void * ) & ( rtDW . p34vnxg4cl ) , sizeof ( rtDW . p34vnxg4cl ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 68 , ( const void * ) & ( rtDW . cshvnu2qj4 ) , sizeof ( rtDW . cshvnu2qj4 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 69 , ( const void * ) & ( rtDW . anun1akbzt ) , sizeof ( rtDW . anun1akbzt ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 70 , ( const void * ) & ( rtDW . k00pa3laqh ) , sizeof ( rtDW . k00pa3laqh ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 71 , ( const void * ) & ( rtDW . omatkykwmc ) , sizeof ( rtDW . omatkykwmc ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 72 , ( const void * ) & ( rtDW . h2aulvebrm ) , sizeof ( rtDW . h2aulvebrm ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 73 , ( const void * ) & ( rtDW . azfivy5wqv ) , sizeof ( rtDW . azfivy5wqv ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 74 , ( const void * ) & ( rtDW . cxaqlklp3z ) , sizeof ( rtDW . cxaqlklp3z ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 75 , ( const void * ) & ( rtDW . bymhg25233 ) , sizeof ( rtDW . bymhg25233 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 76 , ( const void * ) & ( rtDW . bt4dt4cuu2 ) , sizeof ( rtDW . bt4dt4cuu2 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 77 , ( const void * ) & ( rtDW . hssax2olko ) , sizeof ( rtDW . hssax2olko ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 78 , ( const void * ) & ( rtDW . cfai5v52fq ) , sizeof ( rtDW . cfai5v52fq ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 79 , ( const void * ) & ( rtDW . n3w0gkdjc5 ) , sizeof ( rtDW . n3w0gkdjc5 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 80 , ( const void * ) & ( rtDW . kpwsg1fwo4 ) , sizeof ( rtDW . kpwsg1fwo4 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 81 , ( const void * ) & ( rtDW . htlid55lmh ) , sizeof ( rtDW . htlid55lmh ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 82 , ( const void * ) & ( rtDW . hrnpqly234 ) , sizeof ( rtDW . hrnpqly234 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 83 , ( const void * ) & ( rtDW . fffjpdz1bc ) , sizeof ( rtDW . fffjpdz1bc ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 84 , ( const void * ) & ( rtDW . ctlazpcn1r ) , sizeof ( rtDW . ctlazpcn1r ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 85 , ( const void * ) & ( rtDW . gpt4l3gxl0 ) , sizeof ( rtDW . gpt4l3gxl0 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 86 , ( const void * ) & ( rtDW . bwmvjcjrxc ) , sizeof ( rtDW . bwmvjcjrxc ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 87 , ( const void * ) & ( rtDW . ftjkxzybsy ) , sizeof ( rtDW . ftjkxzybsy ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 88 , ( const void * ) & ( rtDW . hrd2dtqf1n ) , sizeof ( rtDW . hrd2dtqf1n ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 89 , ( const void * ) & ( rtDW . dkcwlolqxl ) , sizeof ( rtDW . dkcwlolqxl ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 90 , ( const void * ) & ( rtDW . egry1geo3t ) , sizeof ( rtDW . egry1geo3t ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 91 , ( const void * ) & ( rtDW . gz5an5grm2 ) , sizeof ( rtDW . gz5an5grm2 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 92 , ( const void * ) & ( rtDW . keotauvojf ) , sizeof ( rtDW . keotauvojf ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 93 , ( const void * ) & ( rtDW . glguabnpzh ) , sizeof ( rtDW . glguabnpzh ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 94 , ( const void * ) & ( rtDW . km1goje2r1 ) , sizeof ( rtDW . km1goje2r1 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 95 , ( const void * ) & ( rtDW . mnez3r4wih ) , sizeof ( rtDW . mnez3r4wih ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 96 , ( const void * ) & ( rtDW . cpqsdojs4v ) , sizeof ( rtDW . cpqsdojs4v ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 97 , ( const void * ) & ( rtDW . g3h3iifz4a ) , sizeof ( rtDW . g3h3iifz4a ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 98 , ( const void * ) & ( rtDW . auf11wecna ) , sizeof ( rtDW . auf11wecna ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 99 , ( const void * ) & ( rtDW . eottp2wq2b ) , sizeof ( rtDW . eottp2wq2b ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 100 , ( const void * ) & ( rtDW . hv3cm0cioe ) , sizeof ( rtDW . hv3cm0cioe ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 101 , ( const void * ) & ( rtDW . jtr2pdj40h ) , sizeof ( rtDW . jtr2pdj40h ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 102 , ( const void * ) & ( rtDW . az214v0nqt ) , sizeof ( rtDW . az214v0nqt ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 103 , ( const void * ) & ( rtDW . axtegouoxr ) , sizeof ( rtDW . axtegouoxr ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 104 , ( const void * ) & ( rtDW . ihr0u5jxyq ) , sizeof ( rtDW . ihr0u5jxyq ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 105 , ( const void * ) & ( rtDW . jchleqhuy5 ) , sizeof ( rtDW . jchleqhuy5 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 106 , ( const void * ) & ( rtDW . iu2dpnxnxi ) , sizeof ( rtDW . iu2dpnxnxi ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 107 , ( const void * ) & ( rtDW . ddvsbh4eeb ) , sizeof ( rtDW . ddvsbh4eeb ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 108 , ( const void * ) & ( rtDW . nmgtdqicex ) , sizeof ( rtDW . nmgtdqicex ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 109 , ( const void * ) & ( rtDW . hkz1fvip5h ) , sizeof ( rtDW . hkz1fvip5h ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 110 , ( const void * ) & ( rtDW . b41p410v44 ) , sizeof ( rtDW . b41p410v44 ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 111 , ( const void * ) & ( rtDW . jngltzcitg ) , sizeof ( rtDW . jngltzcitg ) ) ; mr_mm_autograde_M2_nice_cacheDataAsMxArray ( rtdwData , 0 , 112 , ( const void * ) & ( rtDW . hcizcxtpa5 ) , sizeof ( rtDW . hcizcxtpa5 ) ) ; mxSetFieldByNumber ( ssDW , 0 , 1 , rtdwData ) ; } return ssDW ; } void mr_mm_autograde_M2_nice_SetDWork ( const mxArray * ssDW ) { ( void ) ssDW ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtB ) , ssDW , 0 , 0 , sizeof ( rtB ) ) ; { const mxArray * rtdwData = mxGetFieldByNumber ( ssDW , 0 , 1 ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . e2tyz0qrrq ) , rtdwData , 0 , 0 , sizeof ( rtDW . e2tyz0qrrq ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . dupakdsnzz ) , rtdwData , 0 , 1 , sizeof ( rtDW . dupakdsnzz ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . a5hvpj25th ) , rtdwData , 0 , 2 , sizeof ( rtDW . a5hvpj25th ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . i5bvacsh1c ) , rtdwData , 0 , 3 , sizeof ( rtDW . i5bvacsh1c ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . j0pj1cxjdn ) , rtdwData , 0 , 4 , sizeof ( rtDW . j0pj1cxjdn ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hj4s3vhbsm ) , rtdwData , 0 , 5 , sizeof ( rtDW . hj4s3vhbsm ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . n3g3ymlzmr ) , rtdwData , 0 , 6 , sizeof ( rtDW . n3g3ymlzmr ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . gqfi4xcbpq ) , rtdwData , 0 , 7 , sizeof ( rtDW . gqfi4xcbpq ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . nltseoa5tf ) , rtdwData , 0 , 8 , sizeof ( rtDW . nltseoa5tf ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . jf4thnpuad ) , rtdwData , 0 , 9 , sizeof ( rtDW . jf4thnpuad ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . mjsm4xz2fd ) , rtdwData , 0 , 10 , sizeof ( rtDW . mjsm4xz2fd ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . msu0usinuw ) , rtdwData , 0 , 11 , sizeof ( rtDW . msu0usinuw ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . eb5ua2po2y ) , rtdwData , 0 , 12 , sizeof ( rtDW . eb5ua2po2y ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . a4phy4pqvq ) , rtdwData , 0 , 13 , sizeof ( rtDW . a4phy4pqvq ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ht4sfrmguj ) , rtdwData , 0 , 14 , sizeof ( rtDW . ht4sfrmguj ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . fvuqlob3jg ) , rtdwData , 0 , 15 , sizeof ( rtDW . fvuqlob3jg ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ghpi3etgoe ) , rtdwData , 0 , 16 , sizeof ( rtDW . ghpi3etgoe ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . b5ciq54a2a ) , rtdwData , 0 , 17 , sizeof ( rtDW . b5ciq54a2a ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . as3jc4aixp ) , rtdwData , 0 , 18 , sizeof ( rtDW . as3jc4aixp ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . kw4mcnvapg ) , rtdwData , 0 , 19 , sizeof ( rtDW . kw4mcnvapg ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hekbx12zjf ) , rtdwData , 0 , 20 , sizeof ( rtDW . hekbx12zjf ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . dg4bndzwcf ) , rtdwData , 0 , 21 , sizeof ( rtDW . dg4bndzwcf ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . bsz2i3x1zz ) , rtdwData , 0 , 22 , sizeof ( rtDW . bsz2i3x1zz ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . guxmnl3023 ) , rtdwData , 0 , 23 , sizeof ( rtDW . guxmnl3023 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . mkaulxhvv5 ) , rtdwData , 0 , 24 , sizeof ( rtDW . mkaulxhvv5 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . k4bunfh2cu ) , rtdwData , 0 , 25 , sizeof ( rtDW . k4bunfh2cu ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . omd2l4th2w ) , rtdwData , 0 , 26 , sizeof ( rtDW . omd2l4th2w ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ibjaxusqtb ) , rtdwData , 0 , 27 , sizeof ( rtDW . ibjaxusqtb ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . bhzxd4c0jb ) , rtdwData , 0 , 28 , sizeof ( rtDW . bhzxd4c0jb ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . gcoa440zpp ) , rtdwData , 0 , 29 , sizeof ( rtDW . gcoa440zpp ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . fiug4ptcox ) , rtdwData , 0 , 30 , sizeof ( rtDW . fiug4ptcox ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ei11pgnka4 ) , rtdwData , 0 , 31 , sizeof ( rtDW . ei11pgnka4 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hryhffuttt ) , rtdwData , 0 , 32 , sizeof ( rtDW . hryhffuttt ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . pkjabwswri ) , rtdwData , 0 , 33 , sizeof ( rtDW . pkjabwswri ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hvlgcytolm ) , rtdwData , 0 , 34 , sizeof ( rtDW . hvlgcytolm ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ahadgjvl0w ) , rtdwData , 0 , 35 , sizeof ( rtDW . ahadgjvl0w ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hthc5b4czm ) , rtdwData , 0 , 36 , sizeof ( rtDW . hthc5b4czm ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . lsryszinou ) , rtdwData , 0 , 37 , sizeof ( rtDW . lsryszinou ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . jbbzdspg0o ) , rtdwData , 0 , 38 , sizeof ( rtDW . jbbzdspg0o ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . j3fo2xlqpp ) , rtdwData , 0 , 39 , sizeof ( rtDW . j3fo2xlqpp ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . oa1ipehqlk ) , rtdwData , 0 , 40 , sizeof ( rtDW . oa1ipehqlk ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . nk0ebvht3j ) , rtdwData , 0 , 41 , sizeof ( rtDW . nk0ebvht3j ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . oavskvfao1 ) , rtdwData , 0 , 42 , sizeof ( rtDW . oavskvfao1 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . m5xqkkdrpe ) , rtdwData , 0 , 43 , sizeof ( rtDW . m5xqkkdrpe ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . dlac4no1kf ) , rtdwData , 0 , 44 , sizeof ( rtDW . dlac4no1kf ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . kmgfkm3qi1 ) , rtdwData , 0 , 45 , sizeof ( rtDW . kmgfkm3qi1 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . of44i41wjh ) , rtdwData , 0 , 46 , sizeof ( rtDW . of44i41wjh ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . anrkqgyd0y ) , rtdwData , 0 , 47 , sizeof ( rtDW . anrkqgyd0y ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . c0ddl114m0 ) , rtdwData , 0 , 48 , sizeof ( rtDW . c0ddl114m0 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . bpv12jq0j2 ) , rtdwData , 0 , 49 , sizeof ( rtDW . bpv12jq0j2 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . jcrrh2phtm ) , rtdwData , 0 , 50 , sizeof ( rtDW . jcrrh2phtm ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . kjbt4d23ke ) , rtdwData , 0 , 51 , sizeof ( rtDW . kjbt4d23ke ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . jbz5db4uv3 ) , rtdwData , 0 , 52 , sizeof ( rtDW . jbz5db4uv3 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . p1x2oxibuy ) , rtdwData , 0 , 53 , sizeof ( rtDW . p1x2oxibuy ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . boqo1kfngr ) , rtdwData , 0 , 54 , sizeof ( rtDW . boqo1kfngr ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . nmo21jm233 ) , rtdwData , 0 , 55 , sizeof ( rtDW . nmo21jm233 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ppafdi3a1m ) , rtdwData , 0 , 56 , sizeof ( rtDW . ppafdi3a1m ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ag2o5lx0zx ) , rtdwData , 0 , 57 , sizeof ( rtDW . ag2o5lx0zx ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . pinldolpql ) , rtdwData , 0 , 58 , sizeof ( rtDW . pinldolpql ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hivxqwy2wg ) , rtdwData , 0 , 59 , sizeof ( rtDW . hivxqwy2wg ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . p1z00yunkl ) , rtdwData , 0 , 60 , sizeof ( rtDW . p1z00yunkl ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . nls3sblsfo ) , rtdwData , 0 , 61 , sizeof ( rtDW . nls3sblsfo ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . lhfc0ta5ml ) , rtdwData , 0 , 62 , sizeof ( rtDW . lhfc0ta5ml ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . chcmzyq1nu ) , rtdwData , 0 , 63 , sizeof ( rtDW . chcmzyq1nu ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . k5vzkvexn5 ) , rtdwData , 0 , 64 , sizeof ( rtDW . k5vzkvexn5 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hgyf2n5vgw ) , rtdwData , 0 , 65 , sizeof ( rtDW . hgyf2n5vgw ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . n0ab4hkwjr ) , rtdwData , 0 , 66 , sizeof ( rtDW . n0ab4hkwjr ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . p34vnxg4cl ) , rtdwData , 0 , 67 , sizeof ( rtDW . p34vnxg4cl ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . cshvnu2qj4 ) , rtdwData , 0 , 68 , sizeof ( rtDW . cshvnu2qj4 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . anun1akbzt ) , rtdwData , 0 , 69 , sizeof ( rtDW . anun1akbzt ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . k00pa3laqh ) , rtdwData , 0 , 70 , sizeof ( rtDW . k00pa3laqh ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . omatkykwmc ) , rtdwData , 0 , 71 , sizeof ( rtDW . omatkykwmc ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . h2aulvebrm ) , rtdwData , 0 , 72 , sizeof ( rtDW . h2aulvebrm ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . azfivy5wqv ) , rtdwData , 0 , 73 , sizeof ( rtDW . azfivy5wqv ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . cxaqlklp3z ) , rtdwData , 0 , 74 , sizeof ( rtDW . cxaqlklp3z ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . bymhg25233 ) , rtdwData , 0 , 75 , sizeof ( rtDW . bymhg25233 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . bt4dt4cuu2 ) , rtdwData , 0 , 76 , sizeof ( rtDW . bt4dt4cuu2 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hssax2olko ) , rtdwData , 0 , 77 , sizeof ( rtDW . hssax2olko ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . cfai5v52fq ) , rtdwData , 0 , 78 , sizeof ( rtDW . cfai5v52fq ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . n3w0gkdjc5 ) , rtdwData , 0 , 79 , sizeof ( rtDW . n3w0gkdjc5 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . kpwsg1fwo4 ) , rtdwData , 0 , 80 , sizeof ( rtDW . kpwsg1fwo4 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . htlid55lmh ) , rtdwData , 0 , 81 , sizeof ( rtDW . htlid55lmh ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hrnpqly234 ) , rtdwData , 0 , 82 , sizeof ( rtDW . hrnpqly234 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . fffjpdz1bc ) , rtdwData , 0 , 83 , sizeof ( rtDW . fffjpdz1bc ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ctlazpcn1r ) , rtdwData , 0 , 84 , sizeof ( rtDW . ctlazpcn1r ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . gpt4l3gxl0 ) , rtdwData , 0 , 85 , sizeof ( rtDW . gpt4l3gxl0 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . bwmvjcjrxc ) , rtdwData , 0 , 86 , sizeof ( rtDW . bwmvjcjrxc ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ftjkxzybsy ) , rtdwData , 0 , 87 , sizeof ( rtDW . ftjkxzybsy ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hrd2dtqf1n ) , rtdwData , 0 , 88 , sizeof ( rtDW . hrd2dtqf1n ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . dkcwlolqxl ) , rtdwData , 0 , 89 , sizeof ( rtDW . dkcwlolqxl ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . egry1geo3t ) , rtdwData , 0 , 90 , sizeof ( rtDW . egry1geo3t ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . gz5an5grm2 ) , rtdwData , 0 , 91 , sizeof ( rtDW . gz5an5grm2 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . keotauvojf ) , rtdwData , 0 , 92 , sizeof ( rtDW . keotauvojf ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . glguabnpzh ) , rtdwData , 0 , 93 , sizeof ( rtDW . glguabnpzh ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . km1goje2r1 ) , rtdwData , 0 , 94 , sizeof ( rtDW . km1goje2r1 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . mnez3r4wih ) , rtdwData , 0 , 95 , sizeof ( rtDW . mnez3r4wih ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . cpqsdojs4v ) , rtdwData , 0 , 96 , sizeof ( rtDW . cpqsdojs4v ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . g3h3iifz4a ) , rtdwData , 0 , 97 , sizeof ( rtDW . g3h3iifz4a ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . auf11wecna ) , rtdwData , 0 , 98 , sizeof ( rtDW . auf11wecna ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . eottp2wq2b ) , rtdwData , 0 , 99 , sizeof ( rtDW . eottp2wq2b ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hv3cm0cioe ) , rtdwData , 0 , 100 , sizeof ( rtDW . hv3cm0cioe ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . jtr2pdj40h ) , rtdwData , 0 , 101 , sizeof ( rtDW . jtr2pdj40h ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . az214v0nqt ) , rtdwData , 0 , 102 , sizeof ( rtDW . az214v0nqt ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . axtegouoxr ) , rtdwData , 0 , 103 , sizeof ( rtDW . axtegouoxr ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ihr0u5jxyq ) , rtdwData , 0 , 104 , sizeof ( rtDW . ihr0u5jxyq ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . jchleqhuy5 ) , rtdwData , 0 , 105 , sizeof ( rtDW . jchleqhuy5 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . iu2dpnxnxi ) , rtdwData , 0 , 106 , sizeof ( rtDW . iu2dpnxnxi ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . ddvsbh4eeb ) , rtdwData , 0 , 107 , sizeof ( rtDW . ddvsbh4eeb ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . nmgtdqicex ) , rtdwData , 0 , 108 , sizeof ( rtDW . nmgtdqicex ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hkz1fvip5h ) , rtdwData , 0 , 109 , sizeof ( rtDW . hkz1fvip5h ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . b41p410v44 ) , rtdwData , 0 , 110 , sizeof ( rtDW . b41p410v44 ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . jngltzcitg ) , rtdwData , 0 , 111 , sizeof ( rtDW . jngltzcitg ) ) ; mr_mm_autograde_M2_nice_restoreDataFromMxArray ( ( void * ) & ( rtDW . hcizcxtpa5 ) , rtdwData , 0 , 112 , sizeof ( rtDW . hcizcxtpa5 ) ) ; } } mxArray * mr_mm_autograde_M2_nice_GetSimStateDisallowedBlocks ( ) { mxArray * data = mxCreateCellMatrix ( 5 , 3 ) ; mwIndex subs [ 2 ] , offset ; { static const char_T * blockType [ 5 ] = { "Scope" , "Scope" , "Scope" , "Scope" , "" , } ; static const char_T * blockPath [ 5 ] = { "mm_autograde_M2_nice/Subsystem Reference1/Scope3" , "mm_autograde_M2_nice/Subsystem Reference1/Scope4" , "mm_autograde_M2_nice/Subsystem Reference1/Scope2" , "mm_autograde_M2_nice/Subsystem Reference1/Scope1" , "" , } ; static const int reason [ 5 ] = { 0 , 0 , 0 , 0 , 3 , } ; for ( subs [ 0 ] = 0 ; subs [ 0 ] < 5 ; ++ ( subs [ 0 ] ) ) { subs [ 1 ] = 0 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockType [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 1 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockPath [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 2 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateDoubleScalar ( ( real_T ) reason [ subs [ 0 ] ] ) ) ; } } return data ; } void MdlInitializeSizes ( void ) { ssSetNumContStates ( rtS , 7 ) ; ssSetNumPeriodicContStates ( rtS , 0 ) ; ssSetNumY ( rtS , 0 ) ; ssSetNumU ( rtS , 0 ) ; ssSetDirectFeedThrough ( rtS , 0 ) ; ssSetNumSampleTimes ( rtS , 3 ) ; ssSetNumBlocks ( rtS , 157 ) ; ssSetNumBlockIO ( rtS , 66 ) ; ssSetNumBlockParams ( rtS , 56 ) ; } void MdlInitializeSampleTimes ( void ) { ssSetSampleTime ( rtS , 0 , 0.0 ) ; ssSetSampleTime ( rtS , 1 , 0.005 ) ; ssSetSampleTime ( rtS , 2 , 0.01 ) ; ssSetOffsetTime ( rtS , 0 , 0.0 ) ; ssSetOffsetTime ( rtS , 1 , 0.0 ) ; ssSetOffsetTime ( rtS , 2 , 0.0 ) ; } void raccel_set_checksum ( ) { ssSetChecksumVal ( rtS , 0 , 1900629582U ) ; ssSetChecksumVal ( rtS , 1 , 3714603425U ) ; ssSetChecksumVal ( rtS , 2 , 3539306551U ) ; ssSetChecksumVal ( rtS , 3 , 3798494281U ) ; }
#if defined(_MSC_VER)
#pragma optimize( "", off )
#endif
SimStruct * raccel_register_model ( ssExecutionInfo * executionInfo ) {
static struct _ssMdlInfo mdlInfo ; static struct _ssBlkInfo2 blkInfo2 ;
static struct _ssBlkInfoSLSize blkInfoSLSize ; rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; executionInfo -> gblObjects_ . numToFiles = 0 ; executionInfo -> gblObjects_ . numFrFiles = 0 ; executionInfo -> gblObjects_ . numFrWksBlocks = 0 ; executionInfo -> gblObjects_ . numModelInputs = 0 ; executionInfo -> gblObjects_ . numRootInportBlks = 0 ; executionInfo -> gblObjects_ . inportDataTypeIdx = NULL ; executionInfo -> gblObjects_ . inportDims = NULL ; executionInfo -> gblObjects_ . inportComplex = NULL ; executionInfo -> gblObjects_ . inportInterpoFlag = NULL ; executionInfo -> gblObjects_ . inportContinuous = NULL ; ( void ) memset ( ( char_T * ) rtS , 0 , sizeof ( SimStruct ) ) ; ( void ) memset ( ( char_T * ) & mdlInfo , 0 , sizeof ( struct _ssMdlInfo ) ) ; ( void ) memset ( ( char_T * ) & blkInfo2 , 0 , sizeof ( struct _ssBlkInfo2 ) ) ; ( void ) memset ( ( char_T * ) & blkInfoSLSize , 0 , sizeof ( struct _ssBlkInfoSLSize ) ) ; ssSetBlkInfo2Ptr ( rtS , & blkInfo2 ) ; ssSetBlkInfoSLSizePtr ( rtS , & blkInfoSLSize ) ; ssSetMdlInfoPtr ( rtS , & mdlInfo ) ; ssSetExecutionInfo ( rtS , executionInfo ) ; slsaAllocOPModelData ( rtS ) ; { static time_T mdlPeriod [ NSAMPLE_TIMES ] ; static time_T mdlOffset [ NSAMPLE_TIMES ] ; static time_T mdlTaskTimes [ NSAMPLE_TIMES ] ; static int_T mdlTsMap [ NSAMPLE_TIMES ] ; static int_T mdlSampleHits [ NSAMPLE_TIMES ] ; static boolean_T mdlTNextWasAdjustedPtr [ NSAMPLE_TIMES ] ; static int_T mdlPerTaskSampleHits [ NSAMPLE_TIMES * NSAMPLE_TIMES ] ; static time_T mdlTimeOfNextSampleHit [ NSAMPLE_TIMES ] ; { int_T i ; for ( i = 0 ; i < NSAMPLE_TIMES ; i ++ ) { mdlPeriod [ i ] = 0.0 ; mdlOffset [ i ] = 0.0 ; mdlTaskTimes [ i ] = 0.0 ; mdlTsMap [ i ] = i ; mdlSampleHits [ i ] = 1 ; } } ssSetSampleTimePtr ( rtS , & mdlPeriod [ 0 ] ) ; ssSetOffsetTimePtr ( rtS , & mdlOffset [ 0 ] ) ; ssSetSampleTimeTaskIDPtr ( rtS , & mdlTsMap [ 0 ] ) ; ssSetTPtr ( rtS , & mdlTaskTimes [ 0 ] ) ; ssSetSampleHitPtr ( rtS , & mdlSampleHits [ 0 ] ) ; ssSetTNextWasAdjustedPtr ( rtS , & mdlTNextWasAdjustedPtr [ 0 ] ) ; ssSetPerTaskSampleHitsPtr ( rtS , & mdlPerTaskSampleHits [ 0 ] ) ; ssSetTimeOfNextSampleHitPtr ( rtS , & mdlTimeOfNextSampleHit [ 0 ] ) ; } ssSetSolverMode ( rtS , SOLVER_MODE_SINGLETASKING ) ; { ssSetBlockIO ( rtS , ( ( void * ) & rtB ) ) ; ( void ) memset ( ( ( void * ) & rtB ) , 0 , sizeof ( B ) ) ; } suInitializeString ( & rtP . OLED_STRING1_String , "UCT MICROMOUSE '25" ) ; suInitializeString ( & rtP . OLED_STRING2_String , "Simulink Data Demo" ) ; { real_T * x = ( real_T * ) & rtX ; ssSetContStates ( rtS , x ) ; ( void ) memset ( ( void * ) x , 0 , sizeof ( X ) ) ; } { void * dwork = ( void * ) & rtDW ; ssSetRootDWork ( rtS , dwork ) ; ( void ) memset ( dwork , 0 , sizeof ( DW ) ) ; } { static DataTypeTransInfo dtInfo ; ( void ) memset ( ( char_T * ) & dtInfo , 0 , sizeof ( dtInfo ) ) ; ssSetModelMappingInfo ( rtS , & dtInfo ) ; dtInfo . numDataTypes = 28 ; dtInfo . dataTypeSizes = & rtDataTypeSizes [ 0 ] ; dtInfo . dataTypeNames = & rtDataTypeNames [ 0 ] ; dtInfo . BTransTable = & rtBTransTable ; dtInfo . PTransTable = & rtPTransTable ; dtInfo . dataTypeInfoTable = rtDataTypeInfoTable ; } mm_autograde_M2_nice_InitializeDataMapInfo ( ) ; ssSetIsRapidAcceleratorActive ( rtS , true ) ; ssSetRootSS ( rtS , rtS ) ; ssSetVersion ( rtS , SIMSTRUCT_VERSION_LEVEL2 ) ; ssSetModelName ( rtS , "mm_autograde_M2_nice" ) ; ssSetPath ( rtS , "mm_autograde_M2_nice" ) ; ssSetTStart ( rtS , 0.0 ) ; ssSetTFinal ( rtS , 800.0 ) ; ssSetStepSize ( rtS , 0.005 ) ; ssSetFixedStepSize ( rtS , 0.005 ) ; { static RTWLogInfo rt_DataLoggingInfo ; rt_DataLoggingInfo . loggingInterval = ( NULL ) ; ssSetRTWLogInfo ( rtS , & rt_DataLoggingInfo ) ; } { { static int_T rt_LoggedStateWidths [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; static int_T rt_LoggedStateNumDimensions [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; static int_T rt_LoggedStateDimensions [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; static boolean_T rt_LoggedStateIsVarDims [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static BuiltInDTypeId rt_LoggedStateDataTypeIds [ ] = { SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE } ; static int_T rt_LoggedStateComplexSignals [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static RTWPreprocessingFcnPtr rt_LoggingStatePreprocessingFcnPtrs [ ] = { ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) } ; static const char_T * rt_LoggedStateLabels [ ] = { "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "DSTATE" , "DSTATE" , "DSTATE" } ; static const char_T * rt_LoggedStateBlockNames [ ] = { "mm_autograde_M2_nice/mm simple robot/mm robot pose/Integrator" , "mm_autograde_M2_nice/mm simple robot/mm robot pose/Integrator2" , "mm_autograde_M2_nice/mm simple robot/mm robot pose/Integrator1" , "mm_autograde_M2_nice/Subsystem Reference1/Integrator1" , "mm_autograde_M2_nice/mm simple robot/mm wheel encoders/Integrator1" , "mm_autograde_M2_nice/mm simple robot/mm wheel encoders/Integrator" , "mm_autograde_M2_nice/Subsystem Reference1/Integrator" , "mm_autograde_M2_nice/Subsystem Reference1/Low-Pass Filter\n(Discrete or Continuous)3/Integrator\n(Discrete or Continuous)/Discrete/Integrator" , "mm_autograde_M2_nice/Subsystem Reference1/Low-Pass Filter\n(Discrete or Continuous)4/Integrator\n(Discrete or Continuous)/Discrete/Integrator" , "mm_autograde_M2_nice/Subsystem Reference1/Low-Pass Filter\n(Discrete or Continuous)5/Integrator\n(Discrete or Continuous)/Discrete/Integrator" } ; static const char_T * rt_LoggedStateNames [ ] = { "" , "" , "" , "" , "" , "" , "" , "DSTATE" , "DSTATE" , "DSTATE" } ; static boolean_T rt_LoggedStateCrossMdlRef [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert [ ] = { { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } } ; static int_T rt_LoggedStateIdxList [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 0 , 1 , 2 } ; static RTWLogSignalInfo rt_LoggedStateSignalInfo = { 10 , rt_LoggedStateWidths , rt_LoggedStateNumDimensions , rt_LoggedStateDimensions , rt_LoggedStateIsVarDims , ( NULL ) , ( NULL ) , rt_LoggedStateDataTypeIds , rt_LoggedStateComplexSignals , ( NULL ) , rt_LoggingStatePreprocessingFcnPtrs , { rt_LoggedStateLabels } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedStateBlockNames } , { rt_LoggedStateNames } , rt_LoggedStateCrossMdlRef , rt_RTWLogDataTypeConvert , rt_LoggedStateIdxList } ; static void * rt_LoggedStateSignalPtrs [ 10 ] ; rtliSetLogXSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( LogSignalPtrsType ) rt_LoggedStateSignalPtrs ) ; rtliSetLogXSignalInfo ( ssGetRTWLogInfo ( rtS ) , & rt_LoggedStateSignalInfo ) ; rt_LoggedStateSignalPtrs [ 0 ] = ( void * ) & rtX . o3znemhc2a ; rt_LoggedStateSignalPtrs [ 1 ] = ( void * ) & rtX . b3xdnyzu1i ; rt_LoggedStateSignalPtrs [ 2 ] = ( void * ) & rtX . o3b0zoxyg1 ; rt_LoggedStateSignalPtrs [ 3 ] = ( void * ) & rtX . decrl0oxjd ; rt_LoggedStateSignalPtrs [ 4 ] = ( void * ) & rtX . brvdk5f5hy ; rt_LoggedStateSignalPtrs [ 5 ] = ( void * ) & rtX . b414ta1ujl ; rt_LoggedStateSignalPtrs [ 6 ] = ( void * ) & rtX . gjp2vw2s4j ; rt_LoggedStateSignalPtrs [ 7 ] = ( void * ) & rtDW . e2tyz0qrrq ; rt_LoggedStateSignalPtrs [ 8 ] = ( void * ) & rtDW . dupakdsnzz ; rt_LoggedStateSignalPtrs [ 9 ] = ( void * ) & rtDW . a5hvpj25th ; } rtliSetLogT ( ssGetRTWLogInfo ( rtS ) , "tout" ) ; rtliSetLogX ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogXFinal ( ssGetRTWLogInfo ( rtS ) , "xFinal" ) ; rtliSetLogVarNameModifier ( ssGetRTWLogInfo ( rtS ) , "none" ) ; rtliSetLogFormat ( ssGetRTWLogInfo ( rtS ) , 4 ) ; rtliSetLogMaxRows ( ssGetRTWLogInfo ( rtS ) , 0 ) ; rtliSetLogDecimation ( ssGetRTWLogInfo ( rtS ) , 1 ) ; rtliSetLogY ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogYSignalInfo ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; rtliSetLogYSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; } { static struct _ssStatesInfo2 statesInfo2 ; ssSetStatesInfo2 ( rtS , & statesInfo2 ) ; } { static ssPeriodicStatesInfo periodicStatesInfo ; ssSetPeriodicStatesInfo ( rtS , & periodicStatesInfo ) ; } { static ssJacobianPerturbationBounds jacobianPerturbationBounds ; ssSetJacobianPerturbationBounds ( rtS , & jacobianPerturbationBounds ) ; } { static ssSolverInfo slvrInfo ; static boolean_T contStatesDisabled [ 7 ] ; static ssNonContDerivSigInfo nonContDerivSigInfo [ 4 ] = { { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . nbug4ir3tw ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . o3awe1dagi ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . b0avxogppv ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . ggd3q5xetv ) , ( NULL ) } } ; ssSetNumNonContDerivSigInfos ( rtS , 4 ) ; ssSetNonContDerivSigInfos ( rtS , nonContDerivSigInfo ) ; ssSetSolverInfo ( rtS , & slvrInfo ) ; ssSetSolverName ( rtS , "ode3" ) ; ssSetVariableStepSolver ( rtS , 0 ) ; ssSetSolverConsistencyChecking ( rtS , 0 ) ; ssSetSolverAdaptiveZcDetection ( rtS , 0 ) ; ssSetSolverRobustResetMethod ( rtS , 0 ) ; ssSetSolverStateProjection ( rtS , 0 ) ; ssSetSolverMassMatrixType ( rtS , ( ssMatrixType ) 0 ) ; ssSetSolverMassMatrixNzMax ( rtS , 0 ) ; ssSetModelOutputs ( rtS , MdlOutputs ) ; ssSetModelUpdate ( rtS , MdlUpdate ) ; ssSetModelDerivatives ( rtS , MdlDerivatives ) ; ssSetTNextTid ( rtS , INT_MIN ) ; ssSetTNext ( rtS , rtMinusInf ) ; ssSetSolverNeedsReset ( rtS ) ; ssSetNumNonsampledZCs ( rtS , 0 ) ; ssSetContStateDisabled ( rtS , contStatesDisabled ) ; } ssSetChecksumVal ( rtS , 0 , 1900629582U ) ; ssSetChecksumVal ( rtS , 1 , 3714603425U ) ; ssSetChecksumVal ( rtS , 2 , 3539306551U ) ; ssSetChecksumVal ( rtS , 3 , 3798494281U ) ; { static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE ; static RTWExtModeInfo rt_ExtModeInfo ; static const sysRanDType * systemRan [ 13 ] ; gblRTWExtModeInfo = & rt_ExtModeInfo ; ssSetRTWExtModeInfo ( rtS , & rt_ExtModeInfo ) ; rteiSetSubSystemActiveVectorAddresses ( & rt_ExtModeInfo , systemRan ) ; systemRan [ 0 ] = & rtAlwaysEnabled ; systemRan [ 1 ] = ( sysRanDType * ) & rtDW . anun1akbzt ; systemRan [ 2 ] = & rtAlwaysEnabled ; systemRan [ 3 ] = & rtAlwaysEnabled ; systemRan [ 4 ] = & rtAlwaysEnabled ; systemRan [ 5 ] = & rtAlwaysEnabled ; systemRan [ 6 ] = & rtAlwaysEnabled ; systemRan [ 7 ] = & rtAlwaysEnabled ; systemRan [ 8 ] = & rtAlwaysEnabled ; systemRan [ 9 ] = & rtAlwaysEnabled ; systemRan [ 10 ] = & rtAlwaysEnabled ; systemRan [ 11 ] = & rtAlwaysEnabled ; systemRan [ 12 ] = & rtAlwaysEnabled ; rteiSetModelMappingInfoPtr ( ssGetRTWExtModeInfo ( rtS ) , & ssGetModelMappingInfo ( rtS ) ) ; rteiSetChecksumsPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetChecksums ( rtS ) ) ; rteiSetTPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetTPtr ( rtS ) ) ; } slsaDisallowedBlocksForSimTargetOP ( rtS , mr_mm_autograde_M2_nice_GetSimStateDisallowedBlocks ) ; slsaGetWorkFcnForSimTargetOP ( rtS , mr_mm_autograde_M2_nice_GetDWork ) ; slsaSetWorkFcnForSimTargetOP ( rtS , mr_mm_autograde_M2_nice_SetDWork ) ; rt_RapidReadMatFileAndUpdateParams ( rtS ) ; if ( ssGetErrorStatus ( rtS ) ) { return rtS ; } executionInfo -> simulationOptions_ . stateSaveName_ = rtliGetLogX ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . finalStateName_ = rtliGetLogXFinal ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . outputSaveName_ = rtliGetLogY ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . inputTimeTolerance_ = 0.0 ; return rtS ; }
#if defined(_MSC_VER)
#pragma optimize( "", on )
#endif
void MdlOutputsParameterSampleTime ( int_T tid ) { MdlOutputsTID3 ( tid ) ; }
